(self.webpackChunk_zooniverse_fe_project=self.webpackChunk_zooniverse_fe_project||[]).push([[6530],{"../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js":module=>{module.exports=function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/arrayWithHoles.js":module=>{module.exports=function _arrayWithHoles(r){if(Array.isArray(r))return r},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/asyncToGenerator.js":module=>{function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}module.exports=function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/defineProperty.js":(module,__unused_webpack_exports,__webpack_require__)=>{var toPropertyKey=__webpack_require__("../../node_modules/@babel/runtime/helpers/toPropertyKey.js");module.exports=function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":module=>{module.exports=function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/nonIterableRest.js":module=>{module.exports=function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/slicedToArray.js":(module,__unused_webpack_exports,__webpack_require__)=>{var arrayWithHoles=__webpack_require__("../../node_modules/@babel/runtime/helpers/arrayWithHoles.js"),iterableToArrayLimit=__webpack_require__("../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"),unsupportedIterableToArray=__webpack_require__("../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"),nonIterableRest=__webpack_require__("../../node_modules/@babel/runtime/helpers/nonIterableRest.js");module.exports=function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/toPrimitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("../../node_modules/@babel/runtime/helpers/typeof.js").default;module.exports=function toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/toPropertyKey.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("../../node_modules/@babel/runtime/helpers/typeof.js").default,toPrimitive=__webpack_require__("../../node_modules/@babel/runtime/helpers/toPrimitive.js");module.exports=function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":(module,__unused_webpack_exports,__webpack_require__)=>{var arrayLikeToArray=__webpack_require__("../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js");module.exports=function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}},module.exports.__esModule=!0,module.exports.default=module.exports},"../../node_modules/jose/dist/browser/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{CompactEncrypt:()=>CompactEncrypt,CompactSign:()=>CompactSign,EmbeddedJWK:()=>EmbeddedJWK,EncryptJWT:()=>EncryptJWT,FlattenedEncrypt:()=>FlattenedEncrypt,FlattenedSign:()=>FlattenedSign,GeneralEncrypt:()=>GeneralEncrypt,GeneralSign:()=>GeneralSign,SignJWT:()=>SignJWT,UnsecuredJWT:()=>UnsecuredJWT,base64url:()=>util_base64url_namespaceObject,calculateJwkThumbprint:()=>calculateJwkThumbprint,calculateJwkThumbprintUri:()=>calculateJwkThumbprintUri,compactDecrypt:()=>compactDecrypt,compactVerify:()=>compactVerify,createLocalJWKSet:()=>createLocalJWKSet,createRemoteJWKSet:()=>createRemoteJWKSet,cryptoRuntime:()=>util_runtime,decodeJwt:()=>decodeJwt,decodeProtectedHeader:()=>decodeProtectedHeader,errors:()=>errors_namespaceObject,experimental_jwksCache:()=>experimental_jwksCache,exportJWK:()=>exportJWK,exportPKCS8:()=>exportPKCS8,exportSPKI:()=>exportSPKI,flattenedDecrypt:()=>flattenedDecrypt,flattenedVerify:()=>flattenedVerify,generalDecrypt:()=>generalDecrypt,generalVerify:()=>generalVerify,generateKeyPair:()=>generate_key_pair_generateKeyPair,generateSecret:()=>generate_secret_generateSecret,importJWK:()=>importJWK,importPKCS8:()=>importPKCS8,importSPKI:()=>importSPKI,importX509:()=>importX509,jwksCache:()=>jwksCache,jwtDecrypt:()=>jwtDecrypt,jwtVerify:()=>jwtVerify});var errors_namespaceObject={};__webpack_require__.r(errors_namespaceObject),__webpack_require__.d(errors_namespaceObject,{JOSEAlgNotAllowed:()=>JOSEAlgNotAllowed,JOSEError:()=>JOSEError,JOSENotSupported:()=>JOSENotSupported,JWEDecryptionFailed:()=>JWEDecryptionFailed,JWEInvalid:()=>JWEInvalid,JWKInvalid:()=>JWKInvalid,JWKSInvalid:()=>JWKSInvalid,JWKSMultipleMatchingKeys:()=>JWKSMultipleMatchingKeys,JWKSNoMatchingKey:()=>JWKSNoMatchingKey,JWKSTimeout:()=>JWKSTimeout,JWSInvalid:()=>JWSInvalid,JWSSignatureVerificationFailed:()=>JWSSignatureVerificationFailed,JWTClaimValidationFailed:()=>JWTClaimValidationFailed,JWTExpired:()=>JWTExpired,JWTInvalid:()=>JWTInvalid});var util_base64url_namespaceObject={};__webpack_require__.r(util_base64url_namespaceObject),__webpack_require__.d(util_base64url_namespaceObject,{decode:()=>base64url_decode,encode:()=>base64url_encode});const webcrypto=crypto,isCryptoKey=key=>key instanceof CryptoKey,runtime_digest=async(algorithm,data)=>{const subtleDigest=`SHA-${algorithm.slice(-3)}`;return new Uint8Array(await webcrypto.subtle.digest(subtleDigest,data))},encoder=new TextEncoder,decoder=new TextDecoder;function concat(...buffers){const size=buffers.reduce(((acc,{length})=>acc+length),0),buf=new Uint8Array(size);let i=0;for(const buffer of buffers)buf.set(buffer,i),i+=buffer.length;return buf}function writeUInt32BE(buf,value,offset){if(value<0||value>=4294967296)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${value}`);buf.set([value>>>24,value>>>16,value>>>8,255&value],offset)}function uint64be(value){const high=Math.floor(value/4294967296),low=value%4294967296,buf=new Uint8Array(8);return writeUInt32BE(buf,high,0),writeUInt32BE(buf,low,4),buf}function uint32be(value){const buf=new Uint8Array(4);return writeUInt32BE(buf,value),buf}function lengthAndInput(input){return concat(uint32be(input.length),input)}const encodeBase64=input=>{let unencoded=input;"string"==typeof unencoded&&(unencoded=encoder.encode(unencoded));const arr=[];for(let i=0;i<unencoded.length;i+=32768)arr.push(String.fromCharCode.apply(null,unencoded.subarray(i,i+32768)));return btoa(arr.join(""))},encode=input=>encodeBase64(input).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),decodeBase64=encoded=>{const binary=atob(encoded),bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++)bytes[i]=binary.charCodeAt(i);return bytes},decode=input=>{let encoded=input;encoded instanceof Uint8Array&&(encoded=decoder.decode(encoded)),encoded=encoded.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return decodeBase64(encoded)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{constructor(message,options){super(message,options),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}JOSEError.code="ERR_JOSE_GENERIC";class JWTClaimValidationFailed extends JOSEError{constructor(message,payload,claim="unspecified",reason="unspecified"){super(message,{cause:{claim,reason,payload}}),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=claim,this.reason=reason,this.payload=payload}}JWTClaimValidationFailed.code="ERR_JWT_CLAIM_VALIDATION_FAILED";class JWTExpired extends JOSEError{constructor(message,payload,claim="unspecified",reason="unspecified"){super(message,{cause:{claim,reason,payload}}),this.code="ERR_JWT_EXPIRED",this.claim=claim,this.reason=reason,this.payload=payload}}JWTExpired.code="ERR_JWT_EXPIRED";class JOSEAlgNotAllowed extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}}JOSEAlgNotAllowed.code="ERR_JOSE_ALG_NOT_ALLOWED";class JOSENotSupported extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}JOSENotSupported.code="ERR_JOSE_NOT_SUPPORTED";class JWEDecryptionFailed extends JOSEError{constructor(message="decryption operation failed",options){super(message,options),this.code="ERR_JWE_DECRYPTION_FAILED"}}JWEDecryptionFailed.code="ERR_JWE_DECRYPTION_FAILED";class JWEInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}}JWEInvalid.code="ERR_JWE_INVALID";class JWSInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}JWSInvalid.code="ERR_JWS_INVALID";class JWTInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}}JWTInvalid.code="ERR_JWT_INVALID";class JWKInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}}JWKInvalid.code="ERR_JWK_INVALID";class JWKSInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}}JWKSInvalid.code="ERR_JWKS_INVALID";class JWKSNoMatchingKey extends JOSEError{constructor(message="no applicable key found in the JSON Web Key Set",options){super(message,options),this.code="ERR_JWKS_NO_MATCHING_KEY"}}JWKSNoMatchingKey.code="ERR_JWKS_NO_MATCHING_KEY";class JWKSMultipleMatchingKeys extends JOSEError{constructor(message="multiple matching keys found in the JSON Web Key Set",options){super(message,options),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Symbol.asyncIterator,JWKSMultipleMatchingKeys.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";class JWKSTimeout extends JOSEError{constructor(message="request timed out",options){super(message,options),this.code="ERR_JWKS_TIMEOUT"}}JWKSTimeout.code="ERR_JWKS_TIMEOUT";class JWSSignatureVerificationFailed extends JOSEError{constructor(message="signature verification failed",options){super(message,options),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}JWSSignatureVerificationFailed.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";const random=webcrypto.getRandomValues.bind(webcrypto);function bitLength(alg){switch(alg){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`)}}const check_iv_length=(enc,iv)=>{if(iv.length<<3!==bitLength(enc))throw new JWEInvalid("Invalid Initialization Vector length")},check_cek_length=(cek,expected)=>{const actual=cek.byteLength<<3;if(actual!==expected)throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`)},timing_safe_equal=(a,b)=>{if(!(a instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(b instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(a.length!==b.length)throw new TypeError("Input buffers must have the same length");const len=a.length;let out=0,i=-1;for(;++i<len;)out|=a[i]^b[i];return 0===out};function unusable(name,prop="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`)}function isAlgorithm(algorithm,name){return algorithm.name===name}function getHashLength(hash){return parseInt(hash.name.slice(4),10)}function checkUsage(key,usages){if(usages.length&&!usages.some((expected=>key.usages.includes(expected)))){let msg="CryptoKey does not support this operation, its usages must include ";if(usages.length>2){const last=usages.pop();msg+=`one of ${usages.join(", ")}, or ${last}.`}else 2===usages.length?msg+=`one of ${usages[0]} or ${usages[1]}.`:msg+=`${usages[0]}.`;throw new TypeError(msg)}}function checkSigCryptoKey(key,alg,...usages){switch(alg){case"HS256":case"HS384":case"HS512":{if(!isAlgorithm(key.algorithm,"HMAC"))throw unusable("HMAC");const expected=parseInt(alg.slice(2),10);if(getHashLength(key.algorithm.hash)!==expected)throw unusable(`SHA-${expected}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!isAlgorithm(key.algorithm,"RSASSA-PKCS1-v1_5"))throw unusable("RSASSA-PKCS1-v1_5");const expected=parseInt(alg.slice(2),10);if(getHashLength(key.algorithm.hash)!==expected)throw unusable(`SHA-${expected}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!isAlgorithm(key.algorithm,"RSA-PSS"))throw unusable("RSA-PSS");const expected=parseInt(alg.slice(2),10);if(getHashLength(key.algorithm.hash)!==expected)throw unusable(`SHA-${expected}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==key.algorithm.name&&"Ed448"!==key.algorithm.name)throw unusable("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!isAlgorithm(key.algorithm,"ECDSA"))throw unusable("ECDSA");const expected=function getNamedCurve(alg){switch(alg){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(alg);if(key.algorithm.namedCurve!==expected)throw unusable(expected,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(key,usages)}function checkEncCryptoKey(key,alg,...usages){switch(alg){case"A128GCM":case"A192GCM":case"A256GCM":{if(!isAlgorithm(key.algorithm,"AES-GCM"))throw unusable("AES-GCM");const expected=parseInt(alg.slice(1,4),10);if(key.algorithm.length!==expected)throw unusable(expected,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!isAlgorithm(key.algorithm,"AES-KW"))throw unusable("AES-KW");const expected=parseInt(alg.slice(1,4),10);if(key.algorithm.length!==expected)throw unusable(expected,"algorithm.length");break}case"ECDH":switch(key.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw unusable("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!isAlgorithm(key.algorithm,"PBKDF2"))throw unusable("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!isAlgorithm(key.algorithm,"RSA-OAEP"))throw unusable("RSA-OAEP");const expected=parseInt(alg.slice(9),10)||1;if(getHashLength(key.algorithm.hash)!==expected)throw unusable(`SHA-${expected}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(key,usages)}function message(msg,actual,...types){if((types=types.filter(Boolean)).length>2){const last=types.pop();msg+=`one of type ${types.join(", ")}, or ${last}.`}else 2===types.length?msg+=`one of type ${types[0]} or ${types[1]}.`:msg+=`of type ${types[0]}.`;return null==actual?msg+=` Received ${actual}`:"function"==typeof actual&&actual.name?msg+=` Received function ${actual.name}`:"object"==typeof actual&&null!=actual&&actual.constructor?.name&&(msg+=` Received an instance of ${actual.constructor.name}`),msg}const invalid_key_input=(actual,...types)=>message("Key must be ",actual,...types);function withAlg(alg,actual,...types){return message(`Key for the ${alg} algorithm must be `,actual,...types)}const is_key_like=key=>!!isCryptoKey(key)||"KeyObject"===key?.[Symbol.toStringTag],types=["CryptoKey"];const runtime_decrypt=async(enc,cek,ciphertext,iv,tag,aad)=>{if(!(isCryptoKey(cek)||cek instanceof Uint8Array))throw new TypeError(invalid_key_input(cek,...types,"Uint8Array"));if(!iv)throw new JWEInvalid("JWE Initialization Vector missing");if(!tag)throw new JWEInvalid("JWE Authentication Tag missing");switch(check_iv_length(enc,iv),enc){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return cek instanceof Uint8Array&&check_cek_length(cek,parseInt(enc.slice(-3),10)),async function cbcDecrypt(enc,cek,ciphertext,iv,tag,aad){if(!(cek instanceof Uint8Array))throw new TypeError(invalid_key_input(cek,"Uint8Array"));const keySize=parseInt(enc.slice(1,4),10),encKey=await webcrypto.subtle.importKey("raw",cek.subarray(keySize>>3),"AES-CBC",!1,["decrypt"]),macKey=await webcrypto.subtle.importKey("raw",cek.subarray(0,keySize>>3),{hash:"SHA-"+(keySize<<1),name:"HMAC"},!1,["sign"]),macData=concat(aad,iv,ciphertext,uint64be(aad.length<<3)),expectedTag=new Uint8Array((await webcrypto.subtle.sign("HMAC",macKey,macData)).slice(0,keySize>>3));let macCheckPassed,plaintext;try{macCheckPassed=timing_safe_equal(tag,expectedTag)}catch{}if(!macCheckPassed)throw new JWEDecryptionFailed;try{plaintext=new Uint8Array(await webcrypto.subtle.decrypt({iv,name:"AES-CBC"},encKey,ciphertext))}catch{}if(!plaintext)throw new JWEDecryptionFailed;return plaintext}(enc,cek,ciphertext,iv,tag,aad);case"A128GCM":case"A192GCM":case"A256GCM":return cek instanceof Uint8Array&&check_cek_length(cek,parseInt(enc.slice(1,4),10)),async function gcmDecrypt(enc,cek,ciphertext,iv,tag,aad){let encKey;cek instanceof Uint8Array?encKey=await webcrypto.subtle.importKey("raw",cek,"AES-GCM",!1,["decrypt"]):(checkEncCryptoKey(cek,enc,"decrypt"),encKey=cek);try{return new Uint8Array(await webcrypto.subtle.decrypt({additionalData:aad,iv,name:"AES-GCM",tagLength:128},encKey,concat(ciphertext,tag)))}catch{throw new JWEDecryptionFailed}}(enc,cek,ciphertext,iv,tag,aad);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}},is_disjoint=(...headers)=>{const sources=headers.filter(Boolean);if(0===sources.length||1===sources.length)return!0;let acc;for(const header of sources){const parameters=Object.keys(header);if(acc&&0!==acc.size)for(const parameter of parameters){if(acc.has(parameter))return!1;acc.add(parameter)}else acc=new Set(parameters)}return!0};function isObject(input){if(!function isObjectLike(value){return"object"==typeof value&&null!==value}(input)||"[object Object]"!==Object.prototype.toString.call(input))return!1;if(null===Object.getPrototypeOf(input))return!0;let proto=input;for(;null!==Object.getPrototypeOf(proto);)proto=Object.getPrototypeOf(proto);return Object.getPrototypeOf(input)===proto}const bogus=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function checkKeySize(key,alg){if(key.algorithm.length!==parseInt(alg.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${alg}`)}function getCryptoKey(key,alg,usage){if(isCryptoKey(key))return checkEncCryptoKey(key,alg,usage),key;if(key instanceof Uint8Array)return webcrypto.subtle.importKey("raw",key,"AES-KW",!0,[usage]);throw new TypeError(invalid_key_input(key,...types,"Uint8Array"))}const wrap=async(alg,key,cek)=>{const cryptoKey=await getCryptoKey(key,alg,"wrapKey");checkKeySize(cryptoKey,alg);const cryptoKeyCek=await webcrypto.subtle.importKey("raw",cek,...bogus);return new Uint8Array(await webcrypto.subtle.wrapKey("raw",cryptoKeyCek,cryptoKey,"AES-KW"))},unwrap=async(alg,key,encryptedKey)=>{const cryptoKey=await getCryptoKey(key,alg,"unwrapKey");checkKeySize(cryptoKey,alg);const cryptoKeyCek=await webcrypto.subtle.unwrapKey("raw",encryptedKey,cryptoKey,"AES-KW",...bogus);return new Uint8Array(await webcrypto.subtle.exportKey("raw",cryptoKeyCek))};async function deriveKey(publicKey,privateKey,algorithm,keyLength,apu=new Uint8Array(0),apv=new Uint8Array(0)){if(!isCryptoKey(publicKey))throw new TypeError(invalid_key_input(publicKey,...types));if(checkEncCryptoKey(publicKey,"ECDH"),!isCryptoKey(privateKey))throw new TypeError(invalid_key_input(privateKey,...types));checkEncCryptoKey(privateKey,"ECDH","deriveBits");const value=concat(lengthAndInput(encoder.encode(algorithm)),lengthAndInput(apu),lengthAndInput(apv),uint32be(keyLength));let length;length="X25519"===publicKey.algorithm.name?256:"X448"===publicKey.algorithm.name?448:Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function concatKdf(secret,bits,value){const iterations=Math.ceil((bits>>3)/32),res=new Uint8Array(32*iterations);for(let iter=0;iter<iterations;iter++){const buf=new Uint8Array(4+secret.length+value.length);buf.set(uint32be(iter+1)),buf.set(secret,4),buf.set(value,4+secret.length),res.set(await runtime_digest("sha256",buf),32*iter)}return res.slice(0,bits>>3)}(new Uint8Array(await webcrypto.subtle.deriveBits({name:publicKey.algorithm.name,public:publicKey},privateKey,length)),keyLength,value)}function ecdhAllowed(key){if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types));return["P-256","P-384","P-521"].includes(key.algorithm.namedCurve)||"X25519"===key.algorithm.name||"X448"===key.algorithm.name}async function pbes2kw_deriveKey(p2s,alg,p2c,key){!function checkP2s(p2s){if(!(p2s instanceof Uint8Array)||p2s.length<8)throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets")}(p2s);const salt=function buffer_utils_p2s(alg,p2sInput){return concat(encoder.encode(alg),new Uint8Array([0]),p2sInput)}(alg,p2s),keylen=parseInt(alg.slice(13,16),10),subtleAlg={hash:`SHA-${alg.slice(8,11)}`,iterations:p2c,name:"PBKDF2",salt},wrapAlg={length:keylen,name:"AES-KW"},cryptoKey=await function pbes2kw_getCryptoKey(key,alg){if(key instanceof Uint8Array)return webcrypto.subtle.importKey("raw",key,"PBKDF2",!1,["deriveBits"]);if(isCryptoKey(key))return checkEncCryptoKey(key,alg,"deriveBits","deriveKey"),key;throw new TypeError(invalid_key_input(key,...types,"Uint8Array"))}(key,alg);if(cryptoKey.usages.includes("deriveBits"))return new Uint8Array(await webcrypto.subtle.deriveBits(subtleAlg,cryptoKey,keylen));if(cryptoKey.usages.includes("deriveKey"))return webcrypto.subtle.deriveKey(subtleAlg,cryptoKey,wrapAlg,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function subtleRsaEs(alg){switch(alg){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`)}}const check_key_length=(alg,key)=>{if(alg.startsWith("RS")||alg.startsWith("PS")){const{modulusLength}=key.algorithm;if("number"!=typeof modulusLength||modulusLength<2048)throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`)}};function isJWK(key){return isObject(key)&&"string"==typeof key.kty}const jwk_to_key=async jwk=>{if(!jwk.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm,keyUsages}=function subtleMapping(jwk){let algorithm,keyUsages;switch(jwk.kty){case"RSA":switch(jwk.alg){case"PS256":case"PS384":case"PS512":algorithm={name:"RSA-PSS",hash:`SHA-${jwk.alg.slice(-3)}`},keyUsages=jwk.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":algorithm={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${jwk.alg.slice(-3)}`},keyUsages=jwk.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":algorithm={name:"RSA-OAEP",hash:`SHA-${parseInt(jwk.alg.slice(-3),10)||1}`},keyUsages=jwk.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(jwk.alg){case"ES256":algorithm={name:"ECDSA",namedCurve:"P-256"},keyUsages=jwk.d?["sign"]:["verify"];break;case"ES384":algorithm={name:"ECDSA",namedCurve:"P-384"},keyUsages=jwk.d?["sign"]:["verify"];break;case"ES512":algorithm={name:"ECDSA",namedCurve:"P-521"},keyUsages=jwk.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":algorithm={name:"ECDH",namedCurve:jwk.crv},keyUsages=jwk.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(jwk.alg){case"EdDSA":algorithm={name:jwk.crv},keyUsages=jwk.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":algorithm={name:jwk.crv},keyUsages=jwk.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm,keyUsages}}(jwk),rest=[algorithm,jwk.ext??!1,jwk.key_ops??keyUsages],keyData={...jwk};return delete keyData.alg,delete keyData.use,webcrypto.subtle.importKey("jwk",keyData,...rest)},exportKeyValue=k=>decode(k);let privCache,pubCache;const isKeyObject=key=>"KeyObject"===key?.[Symbol.toStringTag],importAndCache=async(cache,key,jwk,alg,freeze=!1)=>{let cached=cache.get(key);if(cached?.[alg])return cached[alg];const cryptoKey=await jwk_to_key({...jwk,alg});return freeze&&Object.freeze(key),cached?cached[alg]=cryptoKey:cache.set(key,{[alg]:cryptoKey}),cryptoKey},normalize_key_normalizePublicKey=(key,alg)=>{if(isKeyObject(key)){let jwk=key.export({format:"jwk"});return delete jwk.d,delete jwk.dp,delete jwk.dq,delete jwk.p,delete jwk.q,delete jwk.qi,jwk.k?exportKeyValue(jwk.k):(pubCache||(pubCache=new WeakMap),importAndCache(pubCache,key,jwk,alg))}if(isJWK(key)){if(key.k)return decode(key.k);pubCache||(pubCache=new WeakMap);return importAndCache(pubCache,key,key,alg,!0)}return key},normalize_key_normalizePrivateKey=(key,alg)=>{if(isKeyObject(key)){let jwk=key.export({format:"jwk"});return jwk.k?exportKeyValue(jwk.k):(privCache||(privCache=new WeakMap),importAndCache(privCache,key,jwk,alg))}if(isJWK(key)){if(key.k)return decode(key.k);privCache||(privCache=new WeakMap);return importAndCache(privCache,key,key,alg,!0)}return key};function cek_bitLength(alg){switch(alg){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`)}}const lib_cek=alg=>random(new Uint8Array(cek_bitLength(alg)>>3)),format_pem=(b64,descriptor)=>`-----BEGIN ${descriptor}-----\n${(b64.match(/.{1,64}/g)||[]).join("\n")}\n-----END ${descriptor}-----`,genericExport=async(keyType,keyFormat,key)=>{if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types));if(!key.extractable)throw new TypeError("CryptoKey is not extractable");if(key.type!==keyType)throw new TypeError(`key is not a ${keyType} key`);return format_pem(encodeBase64(new Uint8Array(await webcrypto.subtle.exportKey(keyFormat,key))),`${keyType.toUpperCase()} KEY`)},toSPKI=key=>genericExport("public","spki",key),toPKCS8=key=>genericExport("private","pkcs8",key),findOid=(keyData,oid,from=0)=>{0===from&&(oid.unshift(oid.length),oid.unshift(6));const i=keyData.indexOf(oid[0],from);if(-1===i)return!1;const sub=keyData.subarray(i,i+oid.length);return sub.length===oid.length&&(sub.every(((value,index)=>value===oid[index]))||findOid(keyData,oid,i+1))},asn1_getNamedCurve=keyData=>{switch(!0){case findOid(keyData,[42,134,72,206,61,3,1,7]):return"P-256";case findOid(keyData,[43,129,4,0,34]):return"P-384";case findOid(keyData,[43,129,4,0,35]):return"P-521";case findOid(keyData,[43,101,110]):return"X25519";case findOid(keyData,[43,101,111]):return"X448";case findOid(keyData,[43,101,112]):return"Ed25519";case findOid(keyData,[43,101,113]):return"Ed448";default:throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},genericImport=async(replace,keyFormat,pem,alg,options)=>{let algorithm,keyUsages;const keyData=new Uint8Array(atob(pem.replace(replace,"")).split("").map((c=>c.charCodeAt(0)))),isPublic="spki"===keyFormat;switch(alg){case"PS256":case"PS384":case"PS512":algorithm={name:"RSA-PSS",hash:`SHA-${alg.slice(-3)}`},keyUsages=isPublic?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":algorithm={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${alg.slice(-3)}`},keyUsages=isPublic?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":algorithm={name:"RSA-OAEP",hash:`SHA-${parseInt(alg.slice(-3),10)||1}`},keyUsages=isPublic?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":algorithm={name:"ECDSA",namedCurve:"P-256"},keyUsages=isPublic?["verify"]:["sign"];break;case"ES384":algorithm={name:"ECDSA",namedCurve:"P-384"},keyUsages=isPublic?["verify"]:["sign"];break;case"ES512":algorithm={name:"ECDSA",namedCurve:"P-521"},keyUsages=isPublic?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const namedCurve=asn1_getNamedCurve(keyData);algorithm=namedCurve.startsWith("P-")?{name:"ECDH",namedCurve}:{name:namedCurve},keyUsages=isPublic?[]:["deriveBits"];break}case"EdDSA":algorithm={name:asn1_getNamedCurve(keyData)},keyUsages=isPublic?["verify"]:["sign"];break;default:throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value')}return webcrypto.subtle.importKey(keyFormat,keyData,algorithm,options?.extractable??!1,keyUsages)},fromPKCS8=(pem,alg,options)=>genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",pem,alg,options),fromSPKI=(pem,alg,options)=>genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",pem,alg,options);function getElement(seq){const result=[];let next=0;for(;next<seq.length;){const nextPart=parseElement(seq.subarray(next));result.push(nextPart),next+=nextPart.byteLength}return result}function parseElement(bytes){let position=0,tag=31&bytes[0];if(position++,31===tag){for(tag=0;bytes[position]>=128;)tag=128*tag+bytes[position]-128,position++;tag=128*tag+bytes[position]-128,position++}let length=0;if(bytes[position]<128)length=bytes[position],position++;else{if(128===length){for(length=0;0!==bytes[position+length]||0!==bytes[position+length+1];){if(length>bytes.byteLength)throw new TypeError("invalid indefinite form length");length++}const byteLength=position+length+2;return{byteLength,contents:bytes.subarray(position,position+length),raw:bytes.subarray(0,byteLength)}}{const numberOfDigits=127&bytes[position];position++,length=0;for(let i=0;i<numberOfDigits;i++)length=256*length+bytes[position],position++}}const byteLength=position+length;return{byteLength,contents:bytes.subarray(position,byteLength),raw:bytes.subarray(0,byteLength)}}function getSPKI(x509){const pem=x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),raw=decodeBase64(pem);return format_pem(function spkiFromX509(buf){const tbsCertificate=getElement(getElement(parseElement(buf).contents)[0].contents);return encodeBase64(tbsCertificate[160===tbsCertificate[0].raw[0]?6:5].raw)}(raw),"PUBLIC KEY")}const fromX509=(pem,alg,options)=>{let spki;try{spki=getSPKI(pem)}catch(cause){throw new TypeError("Failed to parse the X.509 certificate",{cause})}return fromSPKI(spki,alg,options)};async function importSPKI(spki,alg,options){if("string"!=typeof spki||0!==spki.indexOf("-----BEGIN PUBLIC KEY-----"))throw new TypeError('"spki" must be SPKI formatted string');return fromSPKI(spki,alg,options)}async function importX509(x509,alg,options){if("string"!=typeof x509||0!==x509.indexOf("-----BEGIN CERTIFICATE-----"))throw new TypeError('"x509" must be X.509 formatted string');return fromX509(x509,alg,options)}async function importPKCS8(pkcs8,alg,options){if("string"!=typeof pkcs8||0!==pkcs8.indexOf("-----BEGIN PRIVATE KEY-----"))throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return fromPKCS8(pkcs8,alg,options)}async function importJWK(jwk,alg){if(!isObject(jwk))throw new TypeError("JWK must be an object");switch(alg||(alg=jwk.alg),jwk.kty){case"oct":if("string"!=typeof jwk.k||!jwk.k)throw new TypeError('missing "k" (Key Value) Parameter value');return decode(jwk.k);case"RSA":if(void 0!==jwk.oth)throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return jwk_to_key({...jwk,alg});default:throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value')}}const tag=key=>key?.[Symbol.toStringTag],jwkMatchesOp=(alg,key,usage)=>{if(void 0!==key.use&&"sig"!==key.use)throw new TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==key.key_ops&&!0!==key.key_ops.includes?.(usage))throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);if(void 0!==key.alg&&key.alg!==alg)throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);return!0},symmetricTypeCheck=(alg,key,usage,allowJwk)=>{if(!(key instanceof Uint8Array)){if(allowJwk&&isJWK(key)){if(function isSecretJWK(key){return isJWK(key)&&"oct"===key.kty&&"string"==typeof key.k}(key)&&jwkMatchesOp(alg,key,usage))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!is_key_like(key))throw new TypeError(withAlg(alg,key,...types,"Uint8Array",allowJwk?"JSON Web Key":null));if("secret"!==key.type)throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`)}};function checkKeyType(allowJwk,alg,key,usage){alg.startsWith("HS")||"dir"===alg||alg.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(alg)?symmetricTypeCheck(alg,key,usage,allowJwk):((alg,key,usage,allowJwk)=>{if(allowJwk&&isJWK(key))switch(usage){case"sign":if(function isPrivateJWK(key){return"oct"!==key.kty&&"string"==typeof key.d}(key)&&jwkMatchesOp(alg,key,usage))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(function isPublicJWK(key){return"oct"!==key.kty&&void 0===key.d}(key)&&jwkMatchesOp(alg,key,usage))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!is_key_like(key))throw new TypeError(withAlg(alg,key,...types,allowJwk?"JSON Web Key":null));if("secret"===key.type)throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===usage&&"public"===key.type)throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===usage&&"public"===key.type)throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);if(key.algorithm&&"verify"===usage&&"private"===key.type)throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);if(key.algorithm&&"encrypt"===usage&&"private"===key.type)throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`)})(alg,key,usage,allowJwk)}const check_key_type=checkKeyType.bind(void 0,!1),checkKeyTypeWithJwk=checkKeyType.bind(void 0,!0);const runtime_encrypt=async(enc,plaintext,cek,iv,aad)=>{if(!(isCryptoKey(cek)||cek instanceof Uint8Array))throw new TypeError(invalid_key_input(cek,...types,"Uint8Array"));switch(iv?check_iv_length(enc,iv):iv=random(new Uint8Array(bitLength(enc)>>3)),enc){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return cek instanceof Uint8Array&&check_cek_length(cek,parseInt(enc.slice(-3),10)),async function cbcEncrypt(enc,plaintext,cek,iv,aad){if(!(cek instanceof Uint8Array))throw new TypeError(invalid_key_input(cek,"Uint8Array"));const keySize=parseInt(enc.slice(1,4),10),encKey=await webcrypto.subtle.importKey("raw",cek.subarray(keySize>>3),"AES-CBC",!1,["encrypt"]),macKey=await webcrypto.subtle.importKey("raw",cek.subarray(0,keySize>>3),{hash:"SHA-"+(keySize<<1),name:"HMAC"},!1,["sign"]),ciphertext=new Uint8Array(await webcrypto.subtle.encrypt({iv,name:"AES-CBC"},encKey,plaintext)),macData=concat(aad,iv,ciphertext,uint64be(aad.length<<3));return{ciphertext,tag:new Uint8Array((await webcrypto.subtle.sign("HMAC",macKey,macData)).slice(0,keySize>>3)),iv}}(enc,plaintext,cek,iv,aad);case"A128GCM":case"A192GCM":case"A256GCM":return cek instanceof Uint8Array&&check_cek_length(cek,parseInt(enc.slice(1,4),10)),async function gcmEncrypt(enc,plaintext,cek,iv,aad){let encKey;cek instanceof Uint8Array?encKey=await webcrypto.subtle.importKey("raw",cek,"AES-GCM",!1,["encrypt"]):(checkEncCryptoKey(cek,enc,"encrypt"),encKey=cek);const encrypted=new Uint8Array(await webcrypto.subtle.encrypt({additionalData:aad,iv,name:"AES-GCM",tagLength:128},encKey,plaintext)),tag=encrypted.slice(-16);return{ciphertext:encrypted.slice(0,-16),tag,iv}}(enc,plaintext,cek,iv,aad);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}};const decrypt_key_management=async function decryptKeyManagement(alg,key,encryptedKey,joseHeader,options){switch(check_key_type(alg,key,"decrypt"),key=await(normalize_key_normalizePrivateKey?.(key,alg))||key,alg){case"dir":if(void 0!==encryptedKey)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");return key;case"ECDH-ES":if(void 0!==encryptedKey)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!isObject(joseHeader.epk))throw new JWEInvalid('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ecdhAllowed(key))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const epk=await importJWK(joseHeader.epk,alg);let partyUInfo,partyVInfo;if(void 0!==joseHeader.apu){if("string"!=typeof joseHeader.apu)throw new JWEInvalid('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{partyUInfo=decode(joseHeader.apu)}catch{throw new JWEInvalid("Failed to base64url decode the apu")}}if(void 0!==joseHeader.apv){if("string"!=typeof joseHeader.apv)throw new JWEInvalid('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{partyVInfo=decode(joseHeader.apv)}catch{throw new JWEInvalid("Failed to base64url decode the apv")}}const sharedSecret=await deriveKey(epk,key,"ECDH-ES"===alg?joseHeader.enc:alg,"ECDH-ES"===alg?cek_bitLength(joseHeader.enc):parseInt(alg.slice(-5,-2),10),partyUInfo,partyVInfo);if("ECDH-ES"===alg)return sharedSecret;if(void 0===encryptedKey)throw new JWEInvalid("JWE Encrypted Key missing");return unwrap(alg.slice(-6),sharedSecret,encryptedKey)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===encryptedKey)throw new JWEInvalid("JWE Encrypted Key missing");return(async(alg,key,encryptedKey)=>{if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types));if(checkEncCryptoKey(key,alg,"decrypt","unwrapKey"),check_key_length(alg,key),key.usages.includes("decrypt"))return new Uint8Array(await webcrypto.subtle.decrypt(subtleRsaEs(alg),key,encryptedKey));if(key.usages.includes("unwrapKey")){const cryptoKeyCek=await webcrypto.subtle.unwrapKey("raw",encryptedKey,key,subtleRsaEs(alg),...bogus);return new Uint8Array(await webcrypto.subtle.exportKey("raw",cryptoKeyCek))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(alg,key,encryptedKey);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===encryptedKey)throw new JWEInvalid("JWE Encrypted Key missing");if("number"!=typeof joseHeader.p2c)throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) missing or invalid');const p2cLimit=options?.maxPBES2Count||1e4;if(joseHeader.p2c>p2cLimit)throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof joseHeader.p2s)throw new JWEInvalid('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let p2s;try{p2s=decode(joseHeader.p2s)}catch{throw new JWEInvalid("Failed to base64url decode the p2s")}return(async(alg,key,encryptedKey,p2c,p2s)=>{const derived=await pbes2kw_deriveKey(p2s,alg,p2c,key);return unwrap(alg.slice(-6),derived,encryptedKey)})(alg,key,encryptedKey,joseHeader.p2c,p2s)}case"A128KW":case"A192KW":case"A256KW":if(void 0===encryptedKey)throw new JWEInvalid("JWE Encrypted Key missing");return unwrap(alg,key,encryptedKey);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===encryptedKey)throw new JWEInvalid("JWE Encrypted Key missing");if("string"!=typeof joseHeader.iv)throw new JWEInvalid('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof joseHeader.tag)throw new JWEInvalid('JOSE Header "tag" (Authentication Tag) missing or invalid');let iv,tag;try{iv=decode(joseHeader.iv)}catch{throw new JWEInvalid("Failed to base64url decode the iv")}try{tag=decode(joseHeader.tag)}catch{throw new JWEInvalid("Failed to base64url decode the tag")}return async function aesgcmkw_unwrap(alg,key,encryptedKey,iv,tag){const jweAlgorithm=alg.slice(0,7);return runtime_decrypt(jweAlgorithm,key,encryptedKey,iv,tag,new Uint8Array(0))}(alg,key,encryptedKey,iv,tag)}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}};const validate_crit=function validateCrit(Err,recognizedDefault,recognizedOption,protectedHeader,joseHeader){if(void 0!==joseHeader.crit&&void 0===protectedHeader?.crit)throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');if(!protectedHeader||void 0===protectedHeader.crit)return new Set;if(!Array.isArray(protectedHeader.crit)||0===protectedHeader.crit.length||protectedHeader.crit.some((input=>"string"!=typeof input||0===input.length)))throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let recognized;recognized=void 0!==recognizedOption?new Map([...Object.entries(recognizedOption),...recognizedDefault.entries()]):recognizedDefault;for(const parameter of protectedHeader.crit){if(!recognized.has(parameter))throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);if(void 0===joseHeader[parameter])throw new Err(`Extension Header Parameter "${parameter}" is missing`);if(recognized.get(parameter)&&void 0===protectedHeader[parameter])throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`)}return new Set(protectedHeader.crit)},validate_algorithms=(option,algorithms)=>{if(void 0!==algorithms&&(!Array.isArray(algorithms)||algorithms.some((s=>"string"!=typeof s))))throw new TypeError(`"${option}" option must be an array of strings`);if(algorithms)return new Set(algorithms)};async function flattenedDecrypt(jwe,key,options){if(!isObject(jwe))throw new JWEInvalid("Flattened JWE must be an object");if(void 0===jwe.protected&&void 0===jwe.header&&void 0===jwe.unprotected)throw new JWEInvalid("JOSE Header missing");if(void 0!==jwe.iv&&"string"!=typeof jwe.iv)throw new JWEInvalid("JWE Initialization Vector incorrect type");if("string"!=typeof jwe.ciphertext)throw new JWEInvalid("JWE Ciphertext missing or incorrect type");if(void 0!==jwe.tag&&"string"!=typeof jwe.tag)throw new JWEInvalid("JWE Authentication Tag incorrect type");if(void 0!==jwe.protected&&"string"!=typeof jwe.protected)throw new JWEInvalid("JWE Protected Header incorrect type");if(void 0!==jwe.encrypted_key&&"string"!=typeof jwe.encrypted_key)throw new JWEInvalid("JWE Encrypted Key incorrect type");if(void 0!==jwe.aad&&"string"!=typeof jwe.aad)throw new JWEInvalid("JWE AAD incorrect type");if(void 0!==jwe.header&&!isObject(jwe.header))throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");if(void 0!==jwe.unprotected&&!isObject(jwe.unprotected))throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");let parsedProt;if(jwe.protected)try{const protectedHeader=decode(jwe.protected);parsedProt=JSON.parse(decoder.decode(protectedHeader))}catch{throw new JWEInvalid("JWE Protected Header is invalid")}if(!is_disjoint(parsedProt,jwe.header,jwe.unprotected))throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const joseHeader={...parsedProt,...jwe.header,...jwe.unprotected};if(validate_crit(JWEInvalid,new Map,options?.crit,parsedProt,joseHeader),void 0!==joseHeader.zip)throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg,enc}=joseHeader;if("string"!=typeof alg||!alg)throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof enc||!enc)throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");const keyManagementAlgorithms=options&&validate_algorithms("keyManagementAlgorithms",options.keyManagementAlgorithms),contentEncryptionAlgorithms=options&&validate_algorithms("contentEncryptionAlgorithms",options.contentEncryptionAlgorithms);if(keyManagementAlgorithms&&!keyManagementAlgorithms.has(alg)||!keyManagementAlgorithms&&alg.startsWith("PBES2"))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');if(contentEncryptionAlgorithms&&!contentEncryptionAlgorithms.has(enc))throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter value not allowed');let encryptedKey;if(void 0!==jwe.encrypted_key)try{encryptedKey=decode(jwe.encrypted_key)}catch{throw new JWEInvalid("Failed to base64url decode the encrypted_key")}let cek,iv,tag,resolvedKey=!1;"function"==typeof key&&(key=await key(parsedProt,jwe),resolvedKey=!0);try{cek=await decrypt_key_management(alg,key,encryptedKey,joseHeader,options)}catch(err){if(err instanceof TypeError||err instanceof JWEInvalid||err instanceof JOSENotSupported)throw err;cek=lib_cek(enc)}if(void 0!==jwe.iv)try{iv=decode(jwe.iv)}catch{throw new JWEInvalid("Failed to base64url decode the iv")}if(void 0!==jwe.tag)try{tag=decode(jwe.tag)}catch{throw new JWEInvalid("Failed to base64url decode the tag")}const protectedHeader=encoder.encode(jwe.protected??"");let additionalData,ciphertext;additionalData=void 0!==jwe.aad?concat(protectedHeader,encoder.encode("."),encoder.encode(jwe.aad)):protectedHeader;try{ciphertext=decode(jwe.ciphertext)}catch{throw new JWEInvalid("Failed to base64url decode the ciphertext")}const result={plaintext:await runtime_decrypt(enc,cek,ciphertext,iv,tag,additionalData)};if(void 0!==jwe.protected&&(result.protectedHeader=parsedProt),void 0!==jwe.aad)try{result.additionalAuthenticatedData=decode(jwe.aad)}catch{throw new JWEInvalid("Failed to base64url decode the aad")}return void 0!==jwe.unprotected&&(result.sharedUnprotectedHeader=jwe.unprotected),void 0!==jwe.header&&(result.unprotectedHeader=jwe.header),resolvedKey?{...result,key}:result}async function compactDecrypt(jwe,key,options){if(jwe instanceof Uint8Array&&(jwe=decoder.decode(jwe)),"string"!=typeof jwe)throw new JWEInvalid("Compact JWE must be a string or Uint8Array");const{0:protectedHeader,1:encryptedKey,2:iv,3:ciphertext,4:tag,length}=jwe.split(".");if(5!==length)throw new JWEInvalid("Invalid Compact JWE");const decrypted=await flattenedDecrypt({ciphertext,iv:iv||void 0,protected:protectedHeader,tag:tag||void 0,encrypted_key:encryptedKey||void 0},key,options),result={plaintext:decrypted.plaintext,protectedHeader:decrypted.protectedHeader};return"function"==typeof key?{...result,key:decrypted.key}:result}async function generalDecrypt(jwe,key,options){if(!isObject(jwe))throw new JWEInvalid("General JWE must be an object");if(!Array.isArray(jwe.recipients)||!jwe.recipients.every(isObject))throw new JWEInvalid("JWE Recipients missing or incorrect type");if(!jwe.recipients.length)throw new JWEInvalid("JWE Recipients has no members");for(const recipient of jwe.recipients)try{return await flattenedDecrypt({aad:jwe.aad,ciphertext:jwe.ciphertext,encrypted_key:recipient.encrypted_key,header:recipient.header,iv:jwe.iv,protected:jwe.protected,tag:jwe.tag,unprotected:jwe.unprotected},key,options)}catch{}throw new JWEDecryptionFailed}const unprotected=Symbol(),key_to_jwk=async key=>{if(key instanceof Uint8Array)return{kty:"oct",k:encode(key)};if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types,"Uint8Array"));if(!key.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext,key_ops,alg,use,...jwk}=await webcrypto.subtle.exportKey("jwk",key);return jwk};async function exportSPKI(key){return toSPKI(key)}async function exportPKCS8(key){return toPKCS8(key)}async function exportJWK(key){return key_to_jwk(key)}const encrypt_key_management=async function encryptKeyManagement(alg,enc,key,providedCek,providedParameters={}){let encryptedKey,parameters,cek;switch(check_key_type(alg,key,"encrypt"),key=await(normalize_key_normalizePublicKey?.(key,alg))||key,alg){case"dir":cek=key;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ecdhAllowed(key))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu,apv}=providedParameters;let{epk:ephemeralKey}=providedParameters;ephemeralKey||(ephemeralKey=(await async function generateEpk(key){if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types));return webcrypto.subtle.generateKey(key.algorithm,!0,["deriveBits"])}(key)).privateKey);const{x,y,crv,kty}=await exportJWK(ephemeralKey),sharedSecret=await deriveKey(key,ephemeralKey,"ECDH-ES"===alg?enc:alg,"ECDH-ES"===alg?cek_bitLength(enc):parseInt(alg.slice(-5,-2),10),apu,apv);if(parameters={epk:{x,crv,kty}},"EC"===kty&&(parameters.epk.y=y),apu&&(parameters.apu=encode(apu)),apv&&(parameters.apv=encode(apv)),"ECDH-ES"===alg){cek=sharedSecret;break}cek=providedCek||lib_cek(enc);const kwAlg=alg.slice(-6);encryptedKey=await wrap(kwAlg,sharedSecret,cek);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":cek=providedCek||lib_cek(enc),encryptedKey=await(async(alg,key,cek)=>{if(!isCryptoKey(key))throw new TypeError(invalid_key_input(key,...types));if(checkEncCryptoKey(key,alg,"encrypt","wrapKey"),check_key_length(alg,key),key.usages.includes("encrypt"))return new Uint8Array(await webcrypto.subtle.encrypt(subtleRsaEs(alg),key,cek));if(key.usages.includes("wrapKey")){const cryptoKeyCek=await webcrypto.subtle.importKey("raw",cek,...bogus);return new Uint8Array(await webcrypto.subtle.wrapKey("raw",cryptoKeyCek,key,subtleRsaEs(alg)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(alg,key,cek);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{cek=providedCek||lib_cek(enc);const{p2c,p2s}=providedParameters;({encryptedKey,...parameters}=await(async(alg,key,cek,p2c=2048,p2s=random(new Uint8Array(16)))=>{const derived=await pbes2kw_deriveKey(p2s,alg,p2c,key);return{encryptedKey:await wrap(alg.slice(-6),derived,cek),p2c,p2s:encode(p2s)}})(alg,key,cek,p2c,p2s));break}case"A128KW":case"A192KW":case"A256KW":cek=providedCek||lib_cek(enc),encryptedKey=await wrap(alg,key,cek);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{cek=providedCek||lib_cek(enc);const{iv}=providedParameters;({encryptedKey,...parameters}=await async function aesgcmkw_wrap(alg,key,cek,iv){const jweAlgorithm=alg.slice(0,7),wrapped=await runtime_encrypt(jweAlgorithm,cek,key,iv,new Uint8Array(0));return{encryptedKey:wrapped.ciphertext,iv:encode(wrapped.iv),tag:encode(wrapped.tag)}}(alg,key,cek,iv));break}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek,encryptedKey,parameters}};class FlattenedEncrypt{constructor(plaintext){if(!(plaintext instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=plaintext}setKeyManagementParameters(parameters){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=parameters,this}setProtectedHeader(protectedHeader){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=protectedHeader,this}setSharedUnprotectedHeader(sharedUnprotectedHeader){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=sharedUnprotectedHeader,this}setUnprotectedHeader(unprotectedHeader){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=unprotectedHeader,this}setAdditionalAuthenticatedData(aad){return this._aad=aad,this}setContentEncryptionKey(cek){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=cek,this}setInitializationVector(iv){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=iv,this}async encrypt(key,options){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!is_disjoint(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const joseHeader={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(validate_crit(JWEInvalid,new Map,options?.crit,this._protectedHeader,joseHeader),void 0!==joseHeader.zip)throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg,enc}=joseHeader;if("string"!=typeof alg||!alg)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof enc||!enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let encryptedKey,cek,additionalData,protectedHeader,aadMember;if(this._cek&&("dir"===alg||"ECDH-ES"===alg))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${alg}`);{let parameters;({cek,encryptedKey,parameters}=await encrypt_key_management(alg,enc,key,this._cek,this._keyManagementParameters)),parameters&&(options&&unprotected in options?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...parameters}:this.setUnprotectedHeader(parameters):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...parameters}:this.setProtectedHeader(parameters))}protectedHeader=this._protectedHeader?encoder.encode(encode(JSON.stringify(this._protectedHeader))):encoder.encode(""),this._aad?(aadMember=encode(this._aad),additionalData=concat(protectedHeader,encoder.encode("."),encoder.encode(aadMember))):additionalData=protectedHeader;const{ciphertext,tag,iv}=await runtime_encrypt(enc,this._plaintext,cek,this._iv,additionalData),jwe={ciphertext:encode(ciphertext)};return iv&&(jwe.iv=encode(iv)),tag&&(jwe.tag=encode(tag)),encryptedKey&&(jwe.encrypted_key=encode(encryptedKey)),aadMember&&(jwe.aad=aadMember),this._protectedHeader&&(jwe.protected=decoder.decode(protectedHeader)),this._sharedUnprotectedHeader&&(jwe.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(jwe.header=this._unprotectedHeader),jwe}}class IndividualRecipient{constructor(enc,key,options){this.parent=enc,this.key=key,this.options=options}setUnprotectedHeader(unprotectedHeader){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=unprotectedHeader,this}addRecipient(...args){return this.parent.addRecipient(...args)}encrypt(...args){return this.parent.encrypt(...args)}done(){return this.parent}}class GeneralEncrypt{constructor(plaintext){this._recipients=[],this._plaintext=plaintext}addRecipient(key,options){const recipient=new IndividualRecipient(this,key,{crit:options?.crit});return this._recipients.push(recipient),recipient}setProtectedHeader(protectedHeader){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=protectedHeader,this}setSharedUnprotectedHeader(sharedUnprotectedHeader){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=sharedUnprotectedHeader,this}setAdditionalAuthenticatedData(aad){return this._aad=aad,this}async encrypt(){if(!this._recipients.length)throw new JWEInvalid("at least one recipient must be added");if(1===this._recipients.length){const[recipient]=this._recipients,flattened=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key,{...recipient.options}),jwe={ciphertext:flattened.ciphertext,iv:flattened.iv,recipients:[{}],tag:flattened.tag};return flattened.aad&&(jwe.aad=flattened.aad),flattened.protected&&(jwe.protected=flattened.protected),flattened.unprotected&&(jwe.unprotected=flattened.unprotected),flattened.encrypted_key&&(jwe.recipients[0].encrypted_key=flattened.encrypted_key),flattened.header&&(jwe.recipients[0].header=flattened.header),jwe}let enc;for(let i=0;i<this._recipients.length;i++){const recipient=this._recipients[i];if(!is_disjoint(this._protectedHeader,this._unprotectedHeader,recipient.unprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const joseHeader={...this._protectedHeader,...this._unprotectedHeader,...recipient.unprotectedHeader},{alg}=joseHeader;if("string"!=typeof alg||!alg)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===alg||"ECDH-ES"===alg)throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof joseHeader.enc||!joseHeader.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(enc){if(enc!==joseHeader.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else enc=joseHeader.enc;if(validate_crit(JWEInvalid,new Map,recipient.options.crit,this._protectedHeader,joseHeader),void 0!==joseHeader.zip)throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const cek=lib_cek(enc),jwe={ciphertext:"",iv:"",recipients:[],tag:""};for(let i=0;i<this._recipients.length;i++){const recipient=this._recipients[i],target={};jwe.recipients.push(target);const p2c={...this._protectedHeader,...this._unprotectedHeader,...recipient.unprotectedHeader}.alg.startsWith("PBES2")?2048+i:void 0;if(0===i){const flattened=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({p2c}).encrypt(recipient.key,{...recipient.options,[unprotected]:!0});jwe.ciphertext=flattened.ciphertext,jwe.iv=flattened.iv,jwe.tag=flattened.tag,flattened.aad&&(jwe.aad=flattened.aad),flattened.protected&&(jwe.protected=flattened.protected),flattened.unprotected&&(jwe.unprotected=flattened.unprotected),target.encrypted_key=flattened.encrypted_key,flattened.header&&(target.header=flattened.header);continue}const{encryptedKey,parameters}=await encrypt_key_management(recipient.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,enc,recipient.key,cek,{p2c});target.encrypted_key=encode(encryptedKey),(recipient.unprotectedHeader||parameters)&&(target.header={...recipient.unprotectedHeader,...parameters})}return jwe}}function subtleDsa(alg,algorithm){const hash=`SHA-${alg.slice(-3)}`;switch(alg){case"HS256":case"HS384":case"HS512":return{hash,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash,name:"RSA-PSS",saltLength:alg.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash,name:"ECDSA",namedCurve:algorithm.namedCurve};case"EdDSA":return{name:algorithm.name};default:throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`)}}async function get_sign_verify_key_getCryptoKey(alg,key,usage){if("sign"===usage&&(key=await normalize_key_normalizePrivateKey(key,alg)),"verify"===usage&&(key=await normalize_key_normalizePublicKey(key,alg)),isCryptoKey(key))return checkSigCryptoKey(key,alg,usage),key;if(key instanceof Uint8Array){if(!alg.startsWith("HS"))throw new TypeError(invalid_key_input(key,...types));return webcrypto.subtle.importKey("raw",key,{hash:`SHA-${alg.slice(-3)}`,name:"HMAC"},!1,[usage])}throw new TypeError(invalid_key_input(key,...types,"Uint8Array","JSON Web Key"))}const runtime_verify=async(alg,key,signature,data)=>{const cryptoKey=await get_sign_verify_key_getCryptoKey(alg,key,"verify");check_key_length(alg,cryptoKey);const algorithm=subtleDsa(alg,cryptoKey.algorithm);try{return await webcrypto.subtle.verify(algorithm,cryptoKey,signature,data)}catch{return!1}};async function flattenedVerify(jws,key,options){if(!isObject(jws))throw new JWSInvalid("Flattened JWS must be an object");if(void 0===jws.protected&&void 0===jws.header)throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==jws.protected&&"string"!=typeof jws.protected)throw new JWSInvalid("JWS Protected Header incorrect type");if(void 0===jws.payload)throw new JWSInvalid("JWS Payload missing");if("string"!=typeof jws.signature)throw new JWSInvalid("JWS Signature missing or incorrect type");if(void 0!==jws.header&&!isObject(jws.header))throw new JWSInvalid("JWS Unprotected Header incorrect type");let parsedProt={};if(jws.protected)try{const protectedHeader=decode(jws.protected);parsedProt=JSON.parse(decoder.decode(protectedHeader))}catch{throw new JWSInvalid("JWS Protected Header is invalid")}if(!is_disjoint(parsedProt,jws.header))throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const joseHeader={...parsedProt,...jws.header};let b64=!0;if(validate_crit(JWSInvalid,new Map([["b64",!0]]),options?.crit,parsedProt,joseHeader).has("b64")&&(b64=parsedProt.b64,"boolean"!=typeof b64))throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg}=joseHeader;if("string"!=typeof alg||!alg)throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');const algorithms=options&&validate_algorithms("algorithms",options.algorithms);if(algorithms&&!algorithms.has(alg))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');if(b64){if("string"!=typeof jws.payload)throw new JWSInvalid("JWS Payload must be a string")}else if("string"!=typeof jws.payload&&!(jws.payload instanceof Uint8Array))throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");let resolvedKey=!1;"function"==typeof key?(key=await key(parsedProt,jws),resolvedKey=!0,checkKeyTypeWithJwk(alg,key,"verify"),isJWK(key)&&(key=await importJWK(key,alg))):checkKeyTypeWithJwk(alg,key,"verify");const data=concat(encoder.encode(jws.protected??""),encoder.encode("."),"string"==typeof jws.payload?encoder.encode(jws.payload):jws.payload);let signature;try{signature=decode(jws.signature)}catch{throw new JWSInvalid("Failed to base64url decode the signature")}if(!await runtime_verify(alg,key,signature,data))throw new JWSSignatureVerificationFailed;let payload;if(b64)try{payload=decode(jws.payload)}catch{throw new JWSInvalid("Failed to base64url decode the payload")}else payload="string"==typeof jws.payload?encoder.encode(jws.payload):jws.payload;const result={payload};return void 0!==jws.protected&&(result.protectedHeader=parsedProt),void 0!==jws.header&&(result.unprotectedHeader=jws.header),resolvedKey?{...result,key}:result}async function compactVerify(jws,key,options){if(jws instanceof Uint8Array&&(jws=decoder.decode(jws)),"string"!=typeof jws)throw new JWSInvalid("Compact JWS must be a string or Uint8Array");const{0:protectedHeader,1:payload,2:signature,length}=jws.split(".");if(3!==length)throw new JWSInvalid("Invalid Compact JWS");const verified=await flattenedVerify({payload,protected:protectedHeader,signature},key,options),result={payload:verified.payload,protectedHeader:verified.protectedHeader};return"function"==typeof key?{...result,key:verified.key}:result}async function generalVerify(jws,key,options){if(!isObject(jws))throw new JWSInvalid("General JWS must be an object");if(!Array.isArray(jws.signatures)||!jws.signatures.every(isObject))throw new JWSInvalid("JWS Signatures missing or incorrect type");for(const signature of jws.signatures)try{return await flattenedVerify({header:signature.header,payload:jws.payload,protected:signature.protected,signature:signature.signature},key,options)}catch{}throw new JWSSignatureVerificationFailed}const epoch=date=>Math.floor(date.getTime()/1e3),REGEX=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,secs=str=>{const matched=REGEX.exec(str);if(!matched||matched[4]&&matched[1])throw new TypeError("Invalid time period format");const value=parseFloat(matched[2]);let numericDate;switch(matched[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":numericDate=Math.round(value);break;case"minute":case"minutes":case"min":case"mins":case"m":numericDate=Math.round(60*value);break;case"hour":case"hours":case"hr":case"hrs":case"h":numericDate=Math.round(3600*value);break;case"day":case"days":case"d":numericDate=Math.round(86400*value);break;case"week":case"weeks":case"w":numericDate=Math.round(604800*value);break;default:numericDate=Math.round(31557600*value)}return"-"===matched[1]||"ago"===matched[4]?-numericDate:numericDate},normalizeTyp=value=>value.toLowerCase().replace(/^application\//,""),jwt_claims_set=(protectedHeader,encodedPayload,options={})=>{let payload;try{payload=JSON.parse(decoder.decode(encodedPayload))}catch{}if(!isObject(payload))throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");const{typ}=options;if(typ&&("string"!=typeof protectedHeader.typ||normalizeTyp(protectedHeader.typ)!==normalizeTyp(typ)))throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',payload,"typ","check_failed");const{requiredClaims=[],issuer,subject,audience,maxTokenAge}=options,presenceCheck=[...requiredClaims];void 0!==maxTokenAge&&presenceCheck.push("iat"),void 0!==audience&&presenceCheck.push("aud"),void 0!==subject&&presenceCheck.push("sub"),void 0!==issuer&&presenceCheck.push("iss");for(const claim of new Set(presenceCheck.reverse()))if(!(claim in payload))throw new JWTClaimValidationFailed(`missing required "${claim}" claim`,payload,claim,"missing");if(issuer&&!(Array.isArray(issuer)?issuer:[issuer]).includes(payload.iss))throw new JWTClaimValidationFailed('unexpected "iss" claim value',payload,"iss","check_failed");if(subject&&payload.sub!==subject)throw new JWTClaimValidationFailed('unexpected "sub" claim value',payload,"sub","check_failed");if(audience&&(audPayload=payload.aud,audOption="string"==typeof audience?[audience]:audience,!("string"==typeof audPayload?audOption.includes(audPayload):Array.isArray(audPayload)&&audOption.some(Set.prototype.has.bind(new Set(audPayload))))))throw new JWTClaimValidationFailed('unexpected "aud" claim value',payload,"aud","check_failed");var audPayload,audOption;let tolerance;switch(typeof options.clockTolerance){case"string":tolerance=secs(options.clockTolerance);break;case"number":tolerance=options.clockTolerance;break;case"undefined":tolerance=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate}=options,now=epoch(currentDate||new Date);if((void 0!==payload.iat||maxTokenAge)&&"number"!=typeof payload.iat)throw new JWTClaimValidationFailed('"iat" claim must be a number',payload,"iat","invalid");if(void 0!==payload.nbf){if("number"!=typeof payload.nbf)throw new JWTClaimValidationFailed('"nbf" claim must be a number',payload,"nbf","invalid");if(payload.nbf>now+tolerance)throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',payload,"nbf","check_failed")}if(void 0!==payload.exp){if("number"!=typeof payload.exp)throw new JWTClaimValidationFailed('"exp" claim must be a number',payload,"exp","invalid");if(payload.exp<=now-tolerance)throw new JWTExpired('"exp" claim timestamp check failed',payload,"exp","check_failed")}if(maxTokenAge){const age=now-payload.iat;if(age-tolerance>("number"==typeof maxTokenAge?maxTokenAge:secs(maxTokenAge)))throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',payload,"iat","check_failed");if(age<0-tolerance)throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',payload,"iat","check_failed")}return payload};async function jwtVerify(jwt,key,options){const verified=await compactVerify(jwt,key,options);if(verified.protectedHeader.crit?.includes("b64")&&!1===verified.protectedHeader.b64)throw new JWTInvalid("JWTs MUST NOT use unencoded payload");const result={payload:jwt_claims_set(verified.protectedHeader,verified.payload,options),protectedHeader:verified.protectedHeader};return"function"==typeof key?{...result,key:verified.key}:result}async function jwtDecrypt(jwt,key,options){const decrypted=await compactDecrypt(jwt,key,options),payload=jwt_claims_set(decrypted.protectedHeader,decrypted.plaintext,options),{protectedHeader}=decrypted;if(void 0!==protectedHeader.iss&&protectedHeader.iss!==payload.iss)throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch',payload,"iss","mismatch");if(void 0!==protectedHeader.sub&&protectedHeader.sub!==payload.sub)throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch',payload,"sub","mismatch");if(void 0!==protectedHeader.aud&&JSON.stringify(protectedHeader.aud)!==JSON.stringify(payload.aud))throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch',payload,"aud","mismatch");const result={payload,protectedHeader};return"function"==typeof key?{...result,key:decrypted.key}:result}class CompactEncrypt{constructor(plaintext){this._flattened=new FlattenedEncrypt(plaintext)}setContentEncryptionKey(cek){return this._flattened.setContentEncryptionKey(cek),this}setInitializationVector(iv){return this._flattened.setInitializationVector(iv),this}setProtectedHeader(protectedHeader){return this._flattened.setProtectedHeader(protectedHeader),this}setKeyManagementParameters(parameters){return this._flattened.setKeyManagementParameters(parameters),this}async encrypt(key,options){const jwe=await this._flattened.encrypt(key,options);return[jwe.protected,jwe.encrypted_key,jwe.iv,jwe.ciphertext,jwe.tag].join(".")}}const runtime_sign=async(alg,key,data)=>{const cryptoKey=await get_sign_verify_key_getCryptoKey(alg,key,"sign");check_key_length(alg,cryptoKey);const signature=await webcrypto.subtle.sign(subtleDsa(alg,cryptoKey.algorithm),cryptoKey,data);return new Uint8Array(signature)};class FlattenedSign{constructor(payload){if(!(payload instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=payload}setProtectedHeader(protectedHeader){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=protectedHeader,this}setUnprotectedHeader(unprotectedHeader){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=unprotectedHeader,this}async sign(key,options){if(!this._protectedHeader&&!this._unprotectedHeader)throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!is_disjoint(this._protectedHeader,this._unprotectedHeader))throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const joseHeader={...this._protectedHeader,...this._unprotectedHeader};let b64=!0;if(validate_crit(JWSInvalid,new Map([["b64",!0]]),options?.crit,this._protectedHeader,joseHeader).has("b64")&&(b64=this._protectedHeader.b64,"boolean"!=typeof b64))throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg}=joseHeader;if("string"!=typeof alg||!alg)throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');checkKeyTypeWithJwk(alg,key,"sign");let protectedHeader,payload=this._payload;b64&&(payload=encoder.encode(encode(payload))),protectedHeader=this._protectedHeader?encoder.encode(encode(JSON.stringify(this._protectedHeader))):encoder.encode("");const data=concat(protectedHeader,encoder.encode("."),payload),signature=await runtime_sign(alg,key,data),jws={signature:encode(signature),payload:""};return b64&&(jws.payload=decoder.decode(payload)),this._unprotectedHeader&&(jws.header=this._unprotectedHeader),this._protectedHeader&&(jws.protected=decoder.decode(protectedHeader)),jws}}class CompactSign{constructor(payload){this._flattened=new FlattenedSign(payload)}setProtectedHeader(protectedHeader){return this._flattened.setProtectedHeader(protectedHeader),this}async sign(key,options){const jws=await this._flattened.sign(key,options);if(void 0===jws.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${jws.protected}.${jws.payload}.${jws.signature}`}}class IndividualSignature{constructor(sig,key,options){this.parent=sig,this.key=key,this.options=options}setProtectedHeader(protectedHeader){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=protectedHeader,this}setUnprotectedHeader(unprotectedHeader){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=unprotectedHeader,this}addSignature(...args){return this.parent.addSignature(...args)}sign(...args){return this.parent.sign(...args)}done(){return this.parent}}class GeneralSign{constructor(payload){this._signatures=[],this._payload=payload}addSignature(key,options){const signature=new IndividualSignature(this,key,options);return this._signatures.push(signature),signature}async sign(){if(!this._signatures.length)throw new JWSInvalid("at least one signature must be added");const jws={signatures:[],payload:""};for(let i=0;i<this._signatures.length;i++){const signature=this._signatures[i],flattened=new FlattenedSign(this._payload);flattened.setProtectedHeader(signature.protectedHeader),flattened.setUnprotectedHeader(signature.unprotectedHeader);const{payload,...rest}=await flattened.sign(signature.key,signature.options);if(0===i)jws.payload=payload;else if(jws.payload!==payload)throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");jws.signatures.push(rest)}return jws}}function validateInput(label,input){if(!Number.isFinite(input))throw new TypeError(`Invalid ${label} input`);return input}class ProduceJWT{constructor(payload={}){if(!isObject(payload))throw new TypeError("JWT Claims Set MUST be an object");this._payload=payload}setIssuer(issuer){return this._payload={...this._payload,iss:issuer},this}setSubject(subject){return this._payload={...this._payload,sub:subject},this}setAudience(audience){return this._payload={...this._payload,aud:audience},this}setJti(jwtId){return this._payload={...this._payload,jti:jwtId},this}setNotBefore(input){return"number"==typeof input?this._payload={...this._payload,nbf:validateInput("setNotBefore",input)}:input instanceof Date?this._payload={...this._payload,nbf:validateInput("setNotBefore",epoch(input))}:this._payload={...this._payload,nbf:epoch(new Date)+secs(input)},this}setExpirationTime(input){return"number"==typeof input?this._payload={...this._payload,exp:validateInput("setExpirationTime",input)}:input instanceof Date?this._payload={...this._payload,exp:validateInput("setExpirationTime",epoch(input))}:this._payload={...this._payload,exp:epoch(new Date)+secs(input)},this}setIssuedAt(input){return void 0===input?this._payload={...this._payload,iat:epoch(new Date)}:input instanceof Date?this._payload={...this._payload,iat:validateInput("setIssuedAt",epoch(input))}:this._payload="string"==typeof input?{...this._payload,iat:validateInput("setIssuedAt",epoch(new Date)+secs(input))}:{...this._payload,iat:validateInput("setIssuedAt",input)},this}}class SignJWT extends ProduceJWT{setProtectedHeader(protectedHeader){return this._protectedHeader=protectedHeader,this}async sign(key,options){const sig=new CompactSign(encoder.encode(JSON.stringify(this._payload)));if(sig.setProtectedHeader(this._protectedHeader),Array.isArray(this._protectedHeader?.crit)&&this._protectedHeader.crit.includes("b64")&&!1===this._protectedHeader.b64)throw new JWTInvalid("JWTs MUST NOT use unencoded payload");return sig.sign(key,options)}}class EncryptJWT extends ProduceJWT{setProtectedHeader(protectedHeader){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=protectedHeader,this}setKeyManagementParameters(parameters){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=parameters,this}setContentEncryptionKey(cek){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=cek,this}setInitializationVector(iv){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=iv,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(key,options){const enc=new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),enc.setProtectedHeader(this._protectedHeader),this._iv&&enc.setInitializationVector(this._iv),this._cek&&enc.setContentEncryptionKey(this._cek),this._keyManagementParameters&&enc.setKeyManagementParameters(this._keyManagementParameters),enc.encrypt(key,options)}}const check=(value,description)=>{if("string"!=typeof value||!value)throw new JWKInvalid(`${description} missing or invalid`)};async function calculateJwkThumbprint(jwk,digestAlgorithm){if(!isObject(jwk))throw new TypeError("JWK must be an object");if(digestAlgorithm??(digestAlgorithm="sha256"),"sha256"!==digestAlgorithm&&"sha384"!==digestAlgorithm&&"sha512"!==digestAlgorithm)throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let components;switch(jwk.kty){case"EC":check(jwk.crv,'"crv" (Curve) Parameter'),check(jwk.x,'"x" (X Coordinate) Parameter'),check(jwk.y,'"y" (Y Coordinate) Parameter'),components={crv:jwk.crv,kty:jwk.kty,x:jwk.x,y:jwk.y};break;case"OKP":check(jwk.crv,'"crv" (Subtype of Key Pair) Parameter'),check(jwk.x,'"x" (Public Key) Parameter'),components={crv:jwk.crv,kty:jwk.kty,x:jwk.x};break;case"RSA":check(jwk.e,'"e" (Exponent) Parameter'),check(jwk.n,'"n" (Modulus) Parameter'),components={e:jwk.e,kty:jwk.kty,n:jwk.n};break;case"oct":check(jwk.k,'"k" (Key Value) Parameter'),components={k:jwk.k,kty:jwk.kty};break;default:throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported')}const data=encoder.encode(JSON.stringify(components));return encode(await runtime_digest(digestAlgorithm,data))}async function calculateJwkThumbprintUri(jwk,digestAlgorithm){digestAlgorithm??(digestAlgorithm="sha256");const thumbprint=await calculateJwkThumbprint(jwk,digestAlgorithm);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`}async function EmbeddedJWK(protectedHeader,token){const joseHeader={...protectedHeader,...token?.header};if(!isObject(joseHeader.jwk))throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');const key=await importJWK({...joseHeader.jwk,ext:!0},joseHeader.alg);if(key instanceof Uint8Array||"public"!==key.type)throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');return key}function isJWKLike(key){return isObject(key)}function clone(obj){return"function"==typeof structuredClone?structuredClone(obj):JSON.parse(JSON.stringify(obj))}class LocalJWKSet{constructor(jwks){if(this._cached=new WeakMap,!function isJWKSLike(jwks){return jwks&&"object"==typeof jwks&&Array.isArray(jwks.keys)&&jwks.keys.every(isJWKLike)}(jwks))throw new JWKSInvalid("JSON Web Key Set malformed");this._jwks=clone(jwks)}async getKey(protectedHeader,token){const{alg,kid}={...protectedHeader,...token?.header},kty=function getKtyFromAlg(alg){switch("string"==typeof alg&&alg.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set')}}(alg),candidates=this._jwks.keys.filter((jwk=>{let candidate=kty===jwk.kty;if(candidate&&"string"==typeof kid&&(candidate=kid===jwk.kid),candidate&&"string"==typeof jwk.alg&&(candidate=alg===jwk.alg),candidate&&"string"==typeof jwk.use&&(candidate="sig"===jwk.use),candidate&&Array.isArray(jwk.key_ops)&&(candidate=jwk.key_ops.includes("verify")),candidate&&"EdDSA"===alg&&(candidate="Ed25519"===jwk.crv||"Ed448"===jwk.crv),candidate)switch(alg){case"ES256":candidate="P-256"===jwk.crv;break;case"ES256K":candidate="secp256k1"===jwk.crv;break;case"ES384":candidate="P-384"===jwk.crv;break;case"ES512":candidate="P-521"===jwk.crv}return candidate})),{0:jwk,length}=candidates;if(0===length)throw new JWKSNoMatchingKey;if(1!==length){const error=new JWKSMultipleMatchingKeys,{_cached}=this;throw error[Symbol.asyncIterator]=async function*(){for(const jwk of candidates)try{yield await importWithAlgCache(_cached,jwk,alg)}catch{}},error}return importWithAlgCache(this._cached,jwk,alg)}}async function importWithAlgCache(cache,jwk,alg){const cached=cache.get(jwk)||cache.set(jwk,{}).get(jwk);if(void 0===cached[alg]){const key=await importJWK({...jwk,ext:!0},alg);if(key instanceof Uint8Array||"public"!==key.type)throw new JWKSInvalid("JSON Web Key Set members must be public keys");cached[alg]=key}return cached[alg]}function createLocalJWKSet(jwks){const set=new LocalJWKSet(jwks),localJWKSet=async(protectedHeader,token)=>set.getKey(protectedHeader,token);return Object.defineProperties(localJWKSet,{jwks:{value:()=>clone(set._jwks),enumerable:!0,configurable:!1,writable:!1}}),localJWKSet}const fetch_jwks=async(url,timeout,options)=>{let controller,id,timedOut=!1;"function"==typeof AbortController&&(controller=new AbortController,id=setTimeout((()=>{timedOut=!0,controller.abort()}),timeout));const response=await fetch(url.href,{signal:controller?controller.signal:void 0,redirect:"manual",headers:options.headers}).catch((err=>{if(timedOut)throw new JWKSTimeout;throw err}));if(void 0!==id&&clearTimeout(id),200!==response.status)throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await response.json()}catch{throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON")}};let USER_AGENT;if("undefined"==typeof navigator||!navigator.userAgent?.startsWith?.("Mozilla/5.0 ")){USER_AGENT=`${"jose"}/${"v5.9.6"}`}const jwksCache=Symbol();class RemoteJWKSet{constructor(url,options){if(!(url instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(url.href),this._options={agent:options?.agent,headers:options?.headers},this._timeoutDuration="number"==typeof options?.timeoutDuration?options?.timeoutDuration:5e3,this._cooldownDuration="number"==typeof options?.cooldownDuration?options?.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof options?.cacheMaxAge?options?.cacheMaxAge:6e5,void 0!==options?.[jwksCache]&&(this._cache=options?.[jwksCache],function isFreshJwksCache(input,cacheMaxAge){return"object"==typeof input&&null!==input&&"uat"in input&&"number"==typeof input.uat&&!(Date.now()-input.uat>=cacheMaxAge)&&!!("jwks"in input&&isObject(input.jwks)&&Array.isArray(input.jwks.keys)&&Array.prototype.every.call(input.jwks.keys,isObject))}(options?.[jwksCache],this._cacheMaxAge)&&(this._jwksTimestamp=this._cache.uat,this._local=createLocalJWKSet(this._cache.jwks)))}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(protectedHeader,token){this._local&&this.fresh()||await this.reload();try{return await this._local(protectedHeader,token)}catch(err){if(err instanceof JWKSNoMatchingKey&&!1===this.coolingDown())return await this.reload(),this._local(protectedHeader,token);throw err}}async reload(){this._pendingFetch&&function isCloudflareWorkers(){return"undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime}()&&(this._pendingFetch=void 0);const headers=new Headers(this._options.headers);USER_AGENT&&!headers.has("User-Agent")&&(headers.set("User-Agent",USER_AGENT),this._options.headers=Object.fromEntries(headers.entries())),this._pendingFetch||(this._pendingFetch=fetch_jwks(this._url,this._timeoutDuration,this._options).then((json=>{this._local=createLocalJWKSet(json),this._cache&&(this._cache.uat=Date.now(),this._cache.jwks=json),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0})).catch((err=>{throw this._pendingFetch=void 0,err}))),await this._pendingFetch}}function createRemoteJWKSet(url,options){const set=new RemoteJWKSet(url,options),remoteJWKSet=async(protectedHeader,token)=>set.getKey(protectedHeader,token);return Object.defineProperties(remoteJWKSet,{coolingDown:{get:()=>set.coolingDown(),enumerable:!0,configurable:!1},fresh:{get:()=>set.fresh(),enumerable:!0,configurable:!1},reload:{value:()=>set.reload(),enumerable:!0,configurable:!1,writable:!1},reloading:{get:()=>!!set._pendingFetch,enumerable:!0,configurable:!1},jwks:{value:()=>set._local?.jwks(),enumerable:!0,configurable:!1,writable:!1}}),remoteJWKSet}const experimental_jwksCache=jwksCache;class UnsecuredJWT extends ProduceJWT{encode(){return`${encode(JSON.stringify({alg:"none"}))}.${encode(JSON.stringify(this._payload))}.`}static decode(jwt,options){if("string"!=typeof jwt)throw new JWTInvalid("Unsecured JWT must be a string");const{0:encodedHeader,1:encodedPayload,2:signature,length}=jwt.split(".");if(3!==length||""!==signature)throw new JWTInvalid("Invalid Unsecured JWT");let header;try{if(header=JSON.parse(decoder.decode(decode(encodedHeader))),"none"!==header.alg)throw new Error}catch{throw new JWTInvalid("Invalid Unsecured JWT")}return{payload:jwt_claims_set(header,decode(encodedPayload),options),header}}}const base64url_encode=encode,base64url_decode=decode;function decodeProtectedHeader(token){let protectedB64u;if("string"==typeof token){const parts=token.split(".");3!==parts.length&&5!==parts.length||([protectedB64u]=parts)}else if("object"==typeof token&&token){if(!("protected"in token))throw new TypeError("Token does not contain a Protected Header");protectedB64u=token.protected}try{if("string"!=typeof protectedB64u||!protectedB64u)throw new Error;const result=JSON.parse(decoder.decode(base64url_decode(protectedB64u)));if(!isObject(result))throw new Error;return result}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function decodeJwt(jwt){if("string"!=typeof jwt)throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");const{1:payload,length}=jwt.split(".");if(5===length)throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");if(3!==length)throw new JWTInvalid("Invalid JWT");if(!payload)throw new JWTInvalid("JWTs must contain a payload");let decoded,result;try{decoded=base64url_decode(payload)}catch{throw new JWTInvalid("Failed to base64url decode the payload")}try{result=JSON.parse(decoder.decode(decoded))}catch{throw new JWTInvalid("Failed to parse the decoded payload as JSON")}if(!isObject(result))throw new JWTInvalid("Invalid JWT Claims Set");return result}function getModulusLengthOption(options){const modulusLength=options?.modulusLength??2048;if("number"!=typeof modulusLength||modulusLength<2048)throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return modulusLength}async function generate_key_pair_generateKeyPair(alg,options){return async function generateKeyPair(alg,options){let algorithm,keyUsages;switch(alg){case"PS256":case"PS384":case"PS512":algorithm={name:"RSA-PSS",hash:`SHA-${alg.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(options)},keyUsages=["sign","verify"];break;case"RS256":case"RS384":case"RS512":algorithm={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${alg.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(options)},keyUsages=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":algorithm={name:"RSA-OAEP",hash:`SHA-${parseInt(alg.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(options)},keyUsages=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":algorithm={name:"ECDSA",namedCurve:"P-256"},keyUsages=["sign","verify"];break;case"ES384":algorithm={name:"ECDSA",namedCurve:"P-384"},keyUsages=["sign","verify"];break;case"ES512":algorithm={name:"ECDSA",namedCurve:"P-521"},keyUsages=["sign","verify"];break;case"EdDSA":{keyUsages=["sign","verify"];const crv=options?.crv??"Ed25519";switch(crv){case"Ed25519":case"Ed448":algorithm={name:crv};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{keyUsages=["deriveKey","deriveBits"];const crv=options?.crv??"P-256";switch(crv){case"P-256":case"P-384":case"P-521":algorithm={name:"ECDH",namedCurve:crv};break;case"X25519":case"X448":algorithm={name:crv};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return webcrypto.subtle.generateKey(algorithm,options?.extractable??!1,keyUsages)}(alg,options)}async function generate_secret_generateSecret(alg,options){return async function generateSecret(alg,options){let length,algorithm,keyUsages;switch(alg){case"HS256":case"HS384":case"HS512":length=parseInt(alg.slice(-3),10),algorithm={name:"HMAC",hash:`SHA-${length}`,length},keyUsages=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return length=parseInt(alg.slice(-3),10),random(new Uint8Array(length>>3));case"A128KW":case"A192KW":case"A256KW":length=parseInt(alg.slice(1,4),10),algorithm={name:"AES-KW",length},keyUsages=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":length=parseInt(alg.slice(1,4),10),algorithm={name:"AES-GCM",length},keyUsages=["encrypt","decrypt"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return webcrypto.subtle.generateKey(algorithm,options?.extractable??!1,keyUsages)}(alg,options)}const util_runtime="WebCryptoAPI"}}]);