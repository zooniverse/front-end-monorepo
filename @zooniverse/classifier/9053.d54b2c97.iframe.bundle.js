(self.webpackChunk_zooniverse_classifier=self.webpackChunk_zooniverse_classifier||[]).push([[9053],{"../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{useGesture:()=>useGesture,useWheel:()=>useWheel});const V={toVector:(v,fallback)=>(void 0===v&&(v=fallback),Array.isArray(v)?v:[v,v]),add:(v1,v2)=>[v1[0]+v2[0],v1[1]+v2[1]],sub:(v1,v2)=>[v1[0]-v2[0],v1[1]-v2[1]],addTo(v1,v2){v1[0]+=v2[0],v1[1]+=v2[1]},subTo(v1,v2){v1[0]-=v2[0],v1[1]-=v2[1]}};function rubberband(distance,dimension,constant){return 0===dimension||Math.abs(dimension)===1/0?Math.pow(distance,5*constant):distance*dimension*constant/(dimension+constant*distance)}function rubberbandIfOutOfBounds(position,min,max,constant=.15){return 0===constant?function clamp(v,min,max){return Math.max(min,Math.min(v,max))}(position,min,max):position<min?-rubberband(min-position,max-min,constant)+min:position>max?+rubberband(position-max,max-min,constant)+max:position}function _toPropertyKey(arg){var key=function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}(arg,"string");return"symbol"==typeof key?key:String(key)}function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){_defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}const EVENT_TYPE_MAP={pointer:{start:"down",change:"move",end:"up"},mouse:{start:"down",change:"move",end:"up"},touch:{start:"start",change:"move",end:"end"},gesture:{start:"start",change:"change",end:"end"}};function capitalize(string){return string?string[0].toUpperCase()+string.slice(1):""}const actionsWithoutCaptureSupported=["enter","leave"];function toHandlerProp(device,action="",capture=!1){const deviceProps=EVENT_TYPE_MAP[device],actionKey=deviceProps&&deviceProps[action]||action;return"on"+capitalize(device)+capitalize(actionKey)+(function hasCapture(capture=!1,actionKey){return capture&&!actionsWithoutCaptureSupported.includes(actionKey)}(capture,actionKey)?"Capture":"")}const pointerCaptureEvents=["gotpointercapture","lostpointercapture"];function parseProp(prop){let eventKey=prop.substring(2).toLowerCase();const passive=!!~eventKey.indexOf("passive");passive&&(eventKey=eventKey.replace("passive",""));const captureKey=pointerCaptureEvents.includes(eventKey)?"capturecapture":"capture",capture=!!~eventKey.indexOf(captureKey);return capture&&(eventKey=eventKey.replace("capture","")),{device:eventKey,capture,passive}}function isTouch(event){return"touches"in event}function getPointerType(event){return isTouch(event)?"touch":"pointerType"in event?event.pointerType:"mouse"}function getValueEvent(event){return isTouch(event)?function getTouchList(event){return"touchend"===event.type||"touchcancel"===event.type?event.changedTouches:event.targetTouches}(event)[0]:event}function distanceAngle(P1,P2){try{const dx=P2.clientX-P1.clientX,dy=P2.clientY-P1.clientY,cx=(P2.clientX+P1.clientX)/2,cy=(P2.clientY+P1.clientY)/2,distance=Math.hypot(dx,dy),angle=-180*Math.atan2(dx,dy)/Math.PI;return{angle,distance,origin:[cx,cy]}}catch(_unused){}return null}function touchIds(event){return function getCurrentTargetTouchList(event){return Array.from(event.touches).filter((e=>{var _event$currentTarget,_event$currentTarget$;return e.target===event.currentTarget||(null===(_event$currentTarget=event.currentTarget)||void 0===_event$currentTarget||null===(_event$currentTarget$=_event$currentTarget.contains)||void 0===_event$currentTarget$?void 0:_event$currentTarget$.call(_event$currentTarget,e.target))}))}(event).map((touch=>touch.identifier))}function touchDistanceAngle(event,ids){const[P1,P2]=Array.from(event.touches).filter((touch=>ids.includes(touch.identifier)));return distanceAngle(P1,P2)}function pointerId(event){const valueEvent=getValueEvent(event);return isTouch(event)?valueEvent.identifier:valueEvent.pointerId}function pointerValues(event){const valueEvent=getValueEvent(event);return[valueEvent.clientX,valueEvent.clientY]}function wheelValues(event){let{deltaX,deltaY,deltaMode}=event;return 1===deltaMode?(deltaX*=40,deltaY*=40):2===deltaMode&&(deltaX*=800,deltaY*=800),[deltaX,deltaY]}function call(v,...args){return"function"==typeof v?v(...args):v}function noop(){}function chain(...fns){return 0===fns.length?noop:1===fns.length?fns[0]:function(){let result;for(const fn of fns)result=fn.apply(this,arguments)||result;return result}}function assignDefault(value,fallback){return Object.assign({},fallback,value||{})}class Engine{constructor(ctrl,args,key){this.ctrl=ctrl,this.args=args,this.key=key,this.state||(this.state={},this.computeValues([0,0]),this.computeInitial(),this.init&&this.init(),this.reset())}get state(){return this.ctrl.state[this.key]}set state(state){this.ctrl.state[this.key]=state}get shared(){return this.ctrl.state.shared}get eventStore(){return this.ctrl.gestureEventStores[this.key]}get timeoutStore(){return this.ctrl.gestureTimeoutStores[this.key]}get config(){return this.ctrl.config[this.key]}get sharedConfig(){return this.ctrl.config.shared}get handler(){return this.ctrl.handlers[this.key]}reset(){const{state,shared,ingKey,args}=this;shared[ingKey]=state._active=state.active=state._blocked=state._force=!1,state._step=[!1,!1],state.intentional=!1,state._movement=[0,0],state._distance=[0,0],state._direction=[0,0],state._delta=[0,0],state._bounds=[[-1/0,1/0],[-1/0,1/0]],state.args=args,state.axis=void 0,state.memo=void 0,state.elapsedTime=state.timeDelta=0,state.direction=[0,0],state.distance=[0,0],state.overflow=[0,0],state._movementBound=[!1,!1],state.velocity=[0,0],state.movement=[0,0],state.delta=[0,0],state.timeStamp=0}start(event){const state=this.state,config=this.config;state._active||(this.reset(),this.computeInitial(),state._active=!0,state.target=event.target,state.currentTarget=event.currentTarget,state.lastOffset=config.from?call(config.from,state):state.offset,state.offset=state.lastOffset,state.startTime=state.timeStamp=event.timeStamp)}computeValues(values){const state=this.state;state._values=values,state.values=this.config.transform(values)}computeInitial(){const state=this.state;state._initial=state._values,state.initial=state.values}compute(event){const{state,config,shared}=this;state.args=this.args;let dt=0;if(event&&(state.event=event,config.preventDefault&&event.cancelable&&state.event.preventDefault(),state.type=event.type,shared.touches=this.ctrl.pointerIds.size||this.ctrl.touchIds.size,shared.locked=!!document.pointerLockElement,Object.assign(shared,function getEventDetails(event){const payload={};if("buttons"in event&&(payload.buttons=event.buttons),"shiftKey"in event){const{shiftKey,altKey,metaKey,ctrlKey}=event;Object.assign(payload,{shiftKey,altKey,metaKey,ctrlKey})}return payload}(event)),shared.down=shared.pressed=shared.buttons%2==1||shared.touches>0,dt=event.timeStamp-state.timeStamp,state.timeStamp=event.timeStamp,state.elapsedTime=state.timeStamp-state.startTime),state._active){const _absoluteDelta=state._delta.map(Math.abs);V.addTo(state._distance,_absoluteDelta)}this.axisIntent&&this.axisIntent(event);const[_m0,_m1]=state._movement,[t0,t1]=config.threshold,{_step,values}=state;if(config.hasCustomTransform?(!1===_step[0]&&(_step[0]=Math.abs(_m0)>=t0&&values[0]),!1===_step[1]&&(_step[1]=Math.abs(_m1)>=t1&&values[1])):(!1===_step[0]&&(_step[0]=Math.abs(_m0)>=t0&&Math.sign(_m0)*t0),!1===_step[1]&&(_step[1]=Math.abs(_m1)>=t1&&Math.sign(_m1)*t1)),state.intentional=!1!==_step[0]||!1!==_step[1],!state.intentional)return;const movement=[0,0];if(config.hasCustomTransform){const[v0,v1]=values;movement[0]=!1!==_step[0]?v0-_step[0]:0,movement[1]=!1!==_step[1]?v1-_step[1]:0}else movement[0]=!1!==_step[0]?_m0-_step[0]:0,movement[1]=!1!==_step[1]?_m1-_step[1]:0;this.restrictToAxis&&!state._blocked&&this.restrictToAxis(movement);const previousOffset=state.offset,gestureIsActive=state._active&&!state._blocked||state.active;gestureIsActive&&(state.first=state._active&&!state.active,state.last=!state._active&&state.active,state.active=shared[this.ingKey]=state._active,event&&(state.first&&("bounds"in config&&(state._bounds=call(config.bounds,state)),this.setup&&this.setup()),state.movement=movement,this.computeOffset()));const[ox,oy]=state.offset,[[x0,x1],[y0,y1]]=state._bounds;state.overflow=[ox<x0?-1:ox>x1?1:0,oy<y0?-1:oy>y1?1:0],state._movementBound[0]=!!state.overflow[0]&&(!1===state._movementBound[0]?state._movement[0]:state._movementBound[0]),state._movementBound[1]=!!state.overflow[1]&&(!1===state._movementBound[1]?state._movement[1]:state._movementBound[1]);const rubberband=state._active&&config.rubberband||[0,0];if(state.offset=function computeRubberband(bounds,[Vx,Vy],[Rx,Ry]){const[[X0,X1],[Y0,Y1]]=bounds;return[rubberbandIfOutOfBounds(Vx,X0,X1,Rx),rubberbandIfOutOfBounds(Vy,Y0,Y1,Ry)]}(state._bounds,state.offset,rubberband),state.delta=V.sub(state.offset,previousOffset),this.computeMovement(),gestureIsActive&&(!state.last||dt>32)){state.delta=V.sub(state.offset,previousOffset);const absoluteDelta=state.delta.map(Math.abs);V.addTo(state.distance,absoluteDelta),state.direction=state.delta.map(Math.sign),state._direction=state._delta.map(Math.sign),!state.first&&dt>0&&(state.velocity=[absoluteDelta[0]/dt,absoluteDelta[1]/dt],state.timeDelta=dt)}}emit(){const state=this.state,shared=this.shared,config=this.config;if(state._active||this.clean(),(state._blocked||!state.intentional)&&!state._force&&!config.triggerAllEvents)return;const memo=this.handler(_objectSpread2(_objectSpread2(_objectSpread2({},shared),state),{},{[this.aliasKey]:state.values}));void 0!==memo&&(state.memo=memo)}clean(){this.eventStore.clean(),this.timeoutStore.clean()}}class CoordinatesEngine extends Engine{constructor(...args){super(...args),_defineProperty(this,"aliasKey","xy")}reset(){super.reset(),this.state.axis=void 0}init(){this.state.offset=[0,0],this.state.lastOffset=[0,0]}computeOffset(){this.state.offset=V.add(this.state.lastOffset,this.state.movement)}computeMovement(){this.state.movement=V.sub(this.state.offset,this.state.lastOffset)}axisIntent(event){const state=this.state,config=this.config;if(!state.axis&&event){const threshold="object"==typeof config.axisThreshold?config.axisThreshold[getPointerType(event)]:config.axisThreshold;state.axis=function selectAxis([dx,dy],threshold){const absDx=Math.abs(dx),absDy=Math.abs(dy);return absDx>absDy&&absDx>threshold?"x":absDy>absDx&&absDy>threshold?"y":void 0}(state._movement,threshold)}state._blocked=(config.lockDirection||!!config.axis)&&!state.axis||!!config.axis&&config.axis!==state.axis}restrictToAxis(v){if(this.config.axis||this.config.lockDirection)switch(this.state.axis){case"x":v[1]=0;break;case"y":v[0]=0}}}const identity=v=>v,commonConfigResolver={enabled:(value=!0)=>value,eventOptions:(value,_k,config)=>_objectSpread2(_objectSpread2({},config.shared.eventOptions),value),preventDefault:(value=!1)=>value,triggerAllEvents:(value=!1)=>value,rubberband(value=0){switch(value){case!0:return[.15,.15];case!1:return[0,0];default:return V.toVector(value)}},from:value=>"function"==typeof value?value:null!=value?V.toVector(value):void 0,transform(value,_k,config){const transform=value||config.shared.transform;return this.hasCustomTransform=!!transform,transform||identity},threshold:value=>V.toVector(value,0)};const coordinatesConfigResolver=_objectSpread2(_objectSpread2({},commonConfigResolver),{},{axis(_v,_k,{axis}){if(this.lockDirection="lock"===axis,!this.lockDirection)return axis},axisThreshold:(value=0)=>value,bounds(value={}){if("function"==typeof value)return state=>coordinatesConfigResolver.bounds(value(state));if("current"in value)return()=>value.current;if("function"==typeof HTMLElement&&value instanceof HTMLElement)return value;const{left=-1/0,right=1/0,top=-1/0,bottom=1/0}=value;return[[left,right],[top,bottom]]}}),KEYS_DELTA_MAP={ArrowRight:(displacement,factor=1)=>[displacement*factor,0],ArrowLeft:(displacement,factor=1)=>[-1*displacement*factor,0],ArrowUp:(displacement,factor=1)=>[0,-1*displacement*factor],ArrowDown:(displacement,factor=1)=>[0,displacement*factor]};const isBrowser="undefined"!=typeof window&&window.document&&window.document.createElement;function supportsTouchEvents(){return isBrowser&&"ontouchstart"in window}const SUPPORT={isBrowser,gesture:function supportsGestureEvents(){try{return"constructor"in GestureEvent}catch(e){return!1}}(),touch:supportsTouchEvents(),touchscreen:function isTouchScreen(){return supportsTouchEvents()||isBrowser&&window.navigator.maxTouchPoints>1}(),pointer:function supportsPointerEvents(){return isBrowser&&"onpointerdown"in window}(),pointerLock:function supportsPointerLock(){return isBrowser&&"exitPointerLock"in window.document}()},DEFAULT_DRAG_AXIS_THRESHOLD={mouse:0,touch:0,pen:8},dragConfigResolver=_objectSpread2(_objectSpread2({},coordinatesConfigResolver),{},{device(_v,_k,{pointer:{touch=!1,lock=!1,mouse=!1}={}}){return this.pointerLock=lock&&SUPPORT.pointerLock,SUPPORT.touch&&touch?"touch":this.pointerLock?"mouse":SUPPORT.pointer&&!mouse?"pointer":SUPPORT.touch?"touch":"mouse"},preventScrollAxis(value,_k,{preventScroll}){if(this.preventScrollDelay="number"==typeof preventScroll?preventScroll:preventScroll||void 0===preventScroll&&value?250:void 0,SUPPORT.touchscreen&&!1!==preventScroll)return value||(void 0!==preventScroll?"y":void 0)},pointerCapture(_v,_k,{pointer:{capture=!0,buttons=1,keys=!0}={}}){return this.pointerButtons=buttons,this.keys=keys,!this.pointerLock&&"pointer"===this.device&&capture},threshold(value,_k,{filterTaps=!1,tapsThreshold=3,axis}){const threshold=V.toVector(value,filterTaps?tapsThreshold:axis?1:0);return this.filterTaps=filterTaps,this.tapsThreshold=tapsThreshold,threshold},swipe({velocity=.5,distance=50,duration=250}={}){return{velocity:this.transform(V.toVector(velocity)),distance:this.transform(V.toVector(distance)),duration}},delay(value=0){switch(value){case!0:return 180;case!1:return 0;default:return value}},axisThreshold:value=>value?_objectSpread2(_objectSpread2({},DEFAULT_DRAG_AXIS_THRESHOLD),value):DEFAULT_DRAG_AXIS_THRESHOLD,keyboardDisplacement:(value=10)=>value});function clampStateInternalMovementToBounds(state){const[ox,oy]=state.overflow,[dx,dy]=state._delta,[dirx,diry]=state._direction;(ox<0&&dx>0&&dirx<0||ox>0&&dx<0&&dirx>0)&&(state._movement[0]=state._movementBound[0]),(oy<0&&dy>0&&diry<0||oy>0&&dy<0&&diry>0)&&(state._movement[1]=state._movementBound[1])}const pinchConfigResolver=_objectSpread2(_objectSpread2({},commonConfigResolver),{},{device(_v,_k,{shared,pointer:{touch=!1}={}}){if(shared.target&&!SUPPORT.touch&&SUPPORT.gesture)return"gesture";if(SUPPORT.touch&&touch)return"touch";if(SUPPORT.touchscreen){if(SUPPORT.pointer)return"pointer";if(SUPPORT.touch)return"touch"}},bounds(_v,_k,{scaleBounds={},angleBounds={}}){const _scaleBounds=state=>{const D=assignDefault(call(scaleBounds,state),{min:-1/0,max:1/0});return[D.min,D.max]},_angleBounds=state=>{const A=assignDefault(call(angleBounds,state),{min:-1/0,max:1/0});return[A.min,A.max]};return"function"!=typeof scaleBounds&&"function"!=typeof angleBounds?[_scaleBounds(),_angleBounds()]:state=>[_scaleBounds(state),_angleBounds(state)]},threshold(value,_k,config){this.lockDirection="lock"===config.axis;return V.toVector(value,this.lockDirection?[.1,3]:0)},modifierKey:value=>void 0===value?"ctrlKey":value,pinchOnWheel:(value=!0)=>value});const moveConfigResolver=_objectSpread2(_objectSpread2({},coordinatesConfigResolver),{},{mouseOnly:(value=!0)=>value});const scrollConfigResolver=coordinatesConfigResolver;const wheelConfigResolver=coordinatesConfigResolver;const hoverConfigResolver=_objectSpread2(_objectSpread2({},coordinatesConfigResolver),{},{mouseOnly:(value=!0)=>value}),EngineMap=new Map,ConfigResolverMap=new Map;function actions_fe213e88_esm_registerAction(action){EngineMap.set(action.key,action.engine),ConfigResolverMap.set(action.key,action.resolver)}const actions_fe213e88_esm_dragAction={key:"drag",engine:class DragEngine extends CoordinatesEngine{constructor(...args){super(...args),_defineProperty(this,"ingKey","dragging")}reset(){super.reset();const state=this.state;state._pointerId=void 0,state._pointerActive=!1,state._keyboardActive=!1,state._preventScroll=!1,state._delayed=!1,state.swipe=[0,0],state.tap=!1,state.canceled=!1,state.cancel=this.cancel.bind(this)}setup(){const state=this.state;if(state._bounds instanceof HTMLElement){const boundRect=state._bounds.getBoundingClientRect(),targetRect=state.currentTarget.getBoundingClientRect(),_bounds={left:boundRect.left-targetRect.left+state.offset[0],right:boundRect.right-targetRect.right+state.offset[0],top:boundRect.top-targetRect.top+state.offset[1],bottom:boundRect.bottom-targetRect.bottom+state.offset[1]};state._bounds=coordinatesConfigResolver.bounds(_bounds)}}cancel(){const state=this.state;state.canceled||(state.canceled=!0,state._active=!1,setTimeout((()=>{this.compute(),this.emit()}),0))}setActive(){this.state._active=this.state._pointerActive||this.state._keyboardActive}clean(){this.pointerClean(),this.state._pointerActive=!1,this.state._keyboardActive=!1,super.clean()}pointerDown(event){const config=this.config,state=this.state;if(null!=event.buttons&&(Array.isArray(config.pointerButtons)?!config.pointerButtons.includes(event.buttons):-1!==config.pointerButtons&&config.pointerButtons!==event.buttons))return;const ctrlIds=this.ctrl.setEventIds(event);config.pointerCapture&&event.target.setPointerCapture(event.pointerId),ctrlIds&&ctrlIds.size>1&&state._pointerActive||(this.start(event),this.setupPointer(event),state._pointerId=pointerId(event),state._pointerActive=!0,this.computeValues(pointerValues(event)),this.computeInitial(),config.preventScrollAxis&&"mouse"!==getPointerType(event)?(state._active=!1,this.setupScrollPrevention(event)):config.delay>0?(this.setupDelayTrigger(event),config.triggerAllEvents&&(this.compute(event),this.emit())):this.startPointerDrag(event))}startPointerDrag(event){const state=this.state;state._active=!0,state._preventScroll=!0,state._delayed=!1,this.compute(event),this.emit()}pointerMove(event){const state=this.state,config=this.config;if(!state._pointerActive)return;const id=pointerId(event);if(void 0!==state._pointerId&&id!==state._pointerId)return;const _values=pointerValues(event);return document.pointerLockElement===event.target?state._delta=[event.movementX,event.movementY]:(state._delta=V.sub(_values,state._values),this.computeValues(_values)),V.addTo(state._movement,state._delta),this.compute(event),state._delayed&&state.intentional?(this.timeoutStore.remove("dragDelay"),state.active=!1,void this.startPointerDrag(event)):config.preventScrollAxis&&!state._preventScroll?state.axis?state.axis===config.preventScrollAxis||"xy"===config.preventScrollAxis?(state._active=!1,void this.clean()):(this.timeoutStore.remove("startPointerDrag"),void this.startPointerDrag(event)):void 0:void this.emit()}pointerUp(event){this.ctrl.setEventIds(event);try{this.config.pointerCapture&&event.target.hasPointerCapture(event.pointerId)&&event.target.releasePointerCapture(event.pointerId)}catch(_unused){0}const state=this.state,config=this.config;if(!state._active||!state._pointerActive)return;const id=pointerId(event);if(void 0!==state._pointerId&&id!==state._pointerId)return;this.state._pointerActive=!1,this.setActive(),this.compute(event);const[dx,dy]=state._distance;if(state.tap=dx<=config.tapsThreshold&&dy<=config.tapsThreshold,state.tap&&config.filterTaps)state._force=!0;else{const[_dx,_dy]=state._delta,[_mx,_my]=state._movement,[svx,svy]=config.swipe.velocity,[sx,sy]=config.swipe.distance,sdt=config.swipe.duration;if(state.elapsedTime<sdt){const _vx=Math.abs(_dx/state.timeDelta),_vy=Math.abs(_dy/state.timeDelta);_vx>svx&&Math.abs(_mx)>sx&&(state.swipe[0]=Math.sign(_dx)),_vy>svy&&Math.abs(_my)>sy&&(state.swipe[1]=Math.sign(_dy))}}this.emit()}pointerClick(event){!this.state.tap&&event.detail>0&&(event.preventDefault(),event.stopPropagation())}setupPointer(event){const config=this.config,device=config.device;config.pointerLock&&event.currentTarget.requestPointerLock(),config.pointerCapture||(this.eventStore.add(this.sharedConfig.window,device,"change",this.pointerMove.bind(this)),this.eventStore.add(this.sharedConfig.window,device,"end",this.pointerUp.bind(this)),this.eventStore.add(this.sharedConfig.window,device,"cancel",this.pointerUp.bind(this)))}pointerClean(){this.config.pointerLock&&document.pointerLockElement===this.state.currentTarget&&document.exitPointerLock()}preventScroll(event){this.state._preventScroll&&event.cancelable&&event.preventDefault()}setupScrollPrevention(event){this.state._preventScroll=!1,function persistEvent(event){"persist"in event&&"function"==typeof event.persist&&event.persist()}(event);const remove=this.eventStore.add(this.sharedConfig.window,"touch","change",this.preventScroll.bind(this),{passive:!1});this.eventStore.add(this.sharedConfig.window,"touch","end",remove),this.eventStore.add(this.sharedConfig.window,"touch","cancel",remove),this.timeoutStore.add("startPointerDrag",this.startPointerDrag.bind(this),this.config.preventScrollDelay,event)}setupDelayTrigger(event){this.state._delayed=!0,this.timeoutStore.add("dragDelay",(()=>{this.state._step=[0,0],this.startPointerDrag(event)}),this.config.delay)}keyDown(event){const deltaFn=KEYS_DELTA_MAP[event.key];if(deltaFn){const state=this.state,factor=event.shiftKey?10:event.altKey?.1:1;this.start(event),state._delta=deltaFn(this.config.keyboardDisplacement,factor),state._keyboardActive=!0,V.addTo(state._movement,state._delta),this.compute(event),this.emit()}}keyUp(event){event.key in KEYS_DELTA_MAP&&(this.state._keyboardActive=!1,this.setActive(),this.compute(event),this.emit())}bind(bindFunction){const device=this.config.device;bindFunction(device,"start",this.pointerDown.bind(this)),this.config.pointerCapture&&(bindFunction(device,"change",this.pointerMove.bind(this)),bindFunction(device,"end",this.pointerUp.bind(this)),bindFunction(device,"cancel",this.pointerUp.bind(this)),bindFunction("lostPointerCapture","",this.pointerUp.bind(this))),this.config.keys&&(bindFunction("key","down",this.keyDown.bind(this)),bindFunction("key","up",this.keyUp.bind(this))),this.config.filterTaps&&bindFunction("click","",this.pointerClick.bind(this),{capture:!0,passive:!1})}},resolver:dragConfigResolver},actions_fe213e88_esm_hoverAction={key:"hover",engine:class HoverEngine extends CoordinatesEngine{constructor(...args){super(...args),_defineProperty(this,"ingKey","hovering")}enter(event){this.config.mouseOnly&&"mouse"!==event.pointerType||(this.start(event),this.computeValues(pointerValues(event)),this.compute(event),this.emit())}leave(event){if(this.config.mouseOnly&&"mouse"!==event.pointerType)return;const state=this.state;if(!state._active)return;state._active=!1;const values=pointerValues(event);state._movement=state._delta=V.sub(values,state._values),this.computeValues(values),this.compute(event),state.delta=state.movement,this.emit()}bind(bindFunction){bindFunction("pointer","enter",this.enter.bind(this)),bindFunction("pointer","leave",this.leave.bind(this))}},resolver:hoverConfigResolver},actions_fe213e88_esm_moveAction={key:"move",engine:class MoveEngine extends CoordinatesEngine{constructor(...args){super(...args),_defineProperty(this,"ingKey","moving")}move(event){this.config.mouseOnly&&"mouse"!==event.pointerType||(this.state._active?this.moveChange(event):this.moveStart(event),this.timeoutStore.add("moveEnd",this.moveEnd.bind(this)))}moveStart(event){this.start(event),this.computeValues(pointerValues(event)),this.compute(event),this.computeInitial(),this.emit()}moveChange(event){if(!this.state._active)return;const values=pointerValues(event),state=this.state;state._delta=V.sub(values,state._values),V.addTo(state._movement,state._delta),this.computeValues(values),this.compute(event),this.emit()}moveEnd(event){this.state._active&&(this.state._active=!1,this.compute(event),this.emit())}bind(bindFunction){bindFunction("pointer","change",this.move.bind(this)),bindFunction("pointer","leave",this.moveEnd.bind(this))}},resolver:moveConfigResolver},actions_fe213e88_esm_pinchAction={key:"pinch",engine:class PinchEngine extends Engine{constructor(...args){super(...args),_defineProperty(this,"ingKey","pinching"),_defineProperty(this,"aliasKey","da")}init(){this.state.offset=[1,0],this.state.lastOffset=[1,0],this.state._pointerEvents=new Map}reset(){super.reset();const state=this.state;state._touchIds=[],state.canceled=!1,state.cancel=this.cancel.bind(this),state.turns=0}computeOffset(){const{type,movement,lastOffset}=this.state;this.state.offset="wheel"===type?V.add(movement,lastOffset):[(1+movement[0])*lastOffset[0],movement[1]+lastOffset[1]]}computeMovement(){const{offset,lastOffset}=this.state;this.state.movement=[offset[0]/lastOffset[0],offset[1]-lastOffset[1]]}axisIntent(){const state=this.state,[_m0,_m1]=state._movement;if(!state.axis){const axisMovementDifference=30*Math.abs(_m0)-Math.abs(_m1);axisMovementDifference<0?state.axis="angle":axisMovementDifference>0&&(state.axis="scale")}}restrictToAxis(v){this.config.lockDirection&&("scale"===this.state.axis?v[1]=0:"angle"===this.state.axis&&(v[0]=0))}cancel(){const state=this.state;state.canceled||setTimeout((()=>{state.canceled=!0,state._active=!1,this.compute(),this.emit()}),0)}touchStart(event){this.ctrl.setEventIds(event);const state=this.state,ctrlTouchIds=this.ctrl.touchIds;if(state._active&&state._touchIds.every((id=>ctrlTouchIds.has(id))))return;if(ctrlTouchIds.size<2)return;this.start(event),state._touchIds=Array.from(ctrlTouchIds).slice(0,2);const payload=touchDistanceAngle(event,state._touchIds);payload&&this.pinchStart(event,payload)}pointerStart(event){if(null!=event.buttons&&event.buttons%2!=1)return;this.ctrl.setEventIds(event),event.target.setPointerCapture(event.pointerId);const state=this.state,_pointerEvents=state._pointerEvents,ctrlPointerIds=this.ctrl.pointerIds;if(state._active&&Array.from(_pointerEvents.keys()).every((id=>ctrlPointerIds.has(id))))return;if(_pointerEvents.size<2&&_pointerEvents.set(event.pointerId,event),state._pointerEvents.size<2)return;this.start(event);const payload=distanceAngle(...Array.from(_pointerEvents.values()));payload&&this.pinchStart(event,payload)}pinchStart(event,payload){this.state.origin=payload.origin,this.computeValues([payload.distance,payload.angle]),this.computeInitial(),this.compute(event),this.emit()}touchMove(event){if(!this.state._active)return;const payload=touchDistanceAngle(event,this.state._touchIds);payload&&this.pinchMove(event,payload)}pointerMove(event){const _pointerEvents=this.state._pointerEvents;if(_pointerEvents.has(event.pointerId)&&_pointerEvents.set(event.pointerId,event),!this.state._active)return;const payload=distanceAngle(...Array.from(_pointerEvents.values()));payload&&this.pinchMove(event,payload)}pinchMove(event,payload){const state=this.state,prev_a=state._values[1],delta_a=payload.angle-prev_a;let delta_turns=0;Math.abs(delta_a)>270&&(delta_turns+=Math.sign(delta_a)),this.computeValues([payload.distance,payload.angle-360*delta_turns]),state.origin=payload.origin,state.turns=delta_turns,state._movement=[state._values[0]/state._initial[0]-1,state._values[1]-state._initial[1]],this.compute(event),this.emit()}touchEnd(event){this.ctrl.setEventIds(event),this.state._active&&this.state._touchIds.some((id=>!this.ctrl.touchIds.has(id)))&&(this.state._active=!1,this.compute(event),this.emit())}pointerEnd(event){const state=this.state;this.ctrl.setEventIds(event);try{event.target.releasePointerCapture(event.pointerId)}catch(_unused){}state._pointerEvents.has(event.pointerId)&&state._pointerEvents.delete(event.pointerId),state._active&&state._pointerEvents.size<2&&(state._active=!1,this.compute(event),this.emit())}gestureStart(event){event.cancelable&&event.preventDefault();const state=this.state;state._active||(this.start(event),this.computeValues([event.scale,event.rotation]),state.origin=[event.clientX,event.clientY],this.compute(event),this.emit())}gestureMove(event){if(event.cancelable&&event.preventDefault(),!this.state._active)return;const state=this.state;this.computeValues([event.scale,event.rotation]),state.origin=[event.clientX,event.clientY];const _previousMovement=state._movement;state._movement=[event.scale-1,event.rotation],state._delta=V.sub(state._movement,_previousMovement),this.compute(event),this.emit()}gestureEnd(event){this.state._active&&(this.state._active=!1,this.compute(event),this.emit())}wheel(event){const modifierKey=this.config.modifierKey;modifierKey&&!(Array.isArray(modifierKey)?modifierKey.find((k=>event[k])):event[modifierKey])||(this.state._active?this.wheelChange(event):this.wheelStart(event),this.timeoutStore.add("wheelEnd",this.wheelEnd.bind(this)))}wheelStart(event){this.start(event),this.wheelChange(event)}wheelChange(event){"uv"in event||event.cancelable&&event.preventDefault();const state=this.state;state._delta=[-wheelValues(event)[1]/100*state.offset[0],0],V.addTo(state._movement,state._delta),clampStateInternalMovementToBounds(state),this.state.origin=[event.clientX,event.clientY],this.compute(event),this.emit()}wheelEnd(){this.state._active&&(this.state._active=!1,this.compute(),this.emit())}bind(bindFunction){const device=this.config.device;device&&(bindFunction(device,"start",this[device+"Start"].bind(this)),bindFunction(device,"change",this[device+"Move"].bind(this)),bindFunction(device,"end",this[device+"End"].bind(this)),bindFunction(device,"cancel",this[device+"End"].bind(this)),bindFunction("lostPointerCapture","",this[device+"End"].bind(this))),this.config.pinchOnWheel&&bindFunction("wheel","",this.wheel.bind(this),{passive:!1})}},resolver:pinchConfigResolver},actions_fe213e88_esm_scrollAction={key:"scroll",engine:class ScrollEngine extends CoordinatesEngine{constructor(...args){super(...args),_defineProperty(this,"ingKey","scrolling")}scroll(event){this.state._active||this.start(event),this.scrollChange(event),this.timeoutStore.add("scrollEnd",this.scrollEnd.bind(this))}scrollChange(event){event.cancelable&&event.preventDefault();const state=this.state,values=function scrollValues(event){var _ref,_ref2;const{scrollX,scrollY,scrollLeft,scrollTop}=event.currentTarget;return[null!==(_ref=null!=scrollX?scrollX:scrollLeft)&&void 0!==_ref?_ref:0,null!==(_ref2=null!=scrollY?scrollY:scrollTop)&&void 0!==_ref2?_ref2:0]}(event);state._delta=V.sub(values,state._values),V.addTo(state._movement,state._delta),this.computeValues(values),this.compute(event),this.emit()}scrollEnd(){this.state._active&&(this.state._active=!1,this.compute(),this.emit())}bind(bindFunction){bindFunction("scroll","",this.scroll.bind(this))}},resolver:scrollConfigResolver},wheelAction={key:"wheel",engine:class WheelEngine extends CoordinatesEngine{constructor(...args){super(...args),_defineProperty(this,"ingKey","wheeling")}wheel(event){this.state._active||this.start(event),this.wheelChange(event),this.timeoutStore.add("wheelEnd",this.wheelEnd.bind(this))}wheelChange(event){const state=this.state;state._delta=wheelValues(event),V.addTo(state._movement,state._delta),clampStateInternalMovementToBounds(state),this.compute(event),this.emit()}wheelEnd(){this.state._active&&(this.state._active=!1,this.compute(),this.emit())}bind(bindFunction){bindFunction("wheel","",this.wheel.bind(this))}},resolver:wheelConfigResolver};var react=__webpack_require__("../../node_modules/react/index.js");function _objectWithoutProperties(source,excluded){if(null==source)return{};var key,i,target=function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(source,excluded);if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++)key=sourceSymbolKeys[i],excluded.indexOf(key)>=0||Object.prototype.propertyIsEnumerable.call(source,key)&&(target[key]=source[key])}return target}const sharedConfigResolver={target(value){if(value)return()=>"current"in value?value.current:value},enabled:(value=!0)=>value,window:(value=(SUPPORT.isBrowser?window:void 0))=>value,eventOptions:({passive=!0,capture=!1}={})=>({passive,capture}),transform:value=>value},_excluded=["target","eventOptions","window","enabled","transform"];function resolveWith(config={},resolvers){const result={};for(const[key,resolver]of Object.entries(resolvers))switch(typeof resolver){case"function":result[key]=resolver.call(result,config[key],key,config);break;case"object":result[key]=resolveWith(config[key],resolver);break;case"boolean":resolver&&(result[key]=config[key])}return result}class EventStore{constructor(ctrl,gestureKey){_defineProperty(this,"_listeners",new Set),this._ctrl=ctrl,this._gestureKey=gestureKey}add(element,device,action,handler,options){const listeners=this._listeners,type=function toDomEventType(device,action=""){const deviceProps=EVENT_TYPE_MAP[device];return device+(deviceProps&&deviceProps[action]||action)}(device,action),eventOptions=_objectSpread2(_objectSpread2({},this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{}),options);element.addEventListener(type,handler,eventOptions);const remove=()=>{element.removeEventListener(type,handler,eventOptions),listeners.delete(remove)};return listeners.add(remove),remove}clean(){this._listeners.forEach((remove=>remove())),this._listeners.clear()}}class TimeoutStore{constructor(){_defineProperty(this,"_timeouts",new Map)}add(key,callback,ms=140,...args){this.remove(key),this._timeouts.set(key,window.setTimeout(callback,ms,...args))}remove(key){const timeout=this._timeouts.get(key);timeout&&window.clearTimeout(timeout)}clean(){this._timeouts.forEach((timeout=>{window.clearTimeout(timeout)})),this._timeouts.clear()}}class Controller{constructor(handlers){_defineProperty(this,"gestures",new Set),_defineProperty(this,"_targetEventStore",new EventStore(this)),_defineProperty(this,"gestureEventStores",{}),_defineProperty(this,"gestureTimeoutStores",{}),_defineProperty(this,"handlers",{}),_defineProperty(this,"config",{}),_defineProperty(this,"pointerIds",new Set),_defineProperty(this,"touchIds",new Set),_defineProperty(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}}),function resolveGestures(ctrl,internalHandlers){internalHandlers.drag&&setupGesture(ctrl,"drag");internalHandlers.wheel&&setupGesture(ctrl,"wheel");internalHandlers.scroll&&setupGesture(ctrl,"scroll");internalHandlers.move&&setupGesture(ctrl,"move");internalHandlers.pinch&&setupGesture(ctrl,"pinch");internalHandlers.hover&&setupGesture(ctrl,"hover")}(this,handlers)}setEventIds(event){return isTouch(event)?(this.touchIds=new Set(touchIds(event)),this.touchIds):"pointerId"in event?("pointerup"===event.type||"pointercancel"===event.type?this.pointerIds.delete(event.pointerId):"pointerdown"===event.type&&this.pointerIds.add(event.pointerId),this.pointerIds):void 0}applyHandlers(handlers,nativeHandlers){this.handlers=handlers,this.nativeHandlers=nativeHandlers}applyConfig(config,gestureKey){this.config=function parse(newConfig,gestureKey,_config={}){const _ref=newConfig,{target,eventOptions,window,enabled,transform}=_ref,rest=_objectWithoutProperties(_ref,_excluded);if(_config.shared=resolveWith({target,eventOptions,window,enabled,transform},sharedConfigResolver),gestureKey){const resolver=ConfigResolverMap.get(gestureKey);_config[gestureKey]=resolveWith(_objectSpread2({shared:_config.shared},rest),resolver)}else for(const key in rest){const resolver=ConfigResolverMap.get(key);resolver&&(_config[key]=resolveWith(_objectSpread2({shared:_config.shared},rest[key]),resolver))}return _config}(config,gestureKey,this.config)}clean(){this._targetEventStore.clean();for(const key of this.gestures)this.gestureEventStores[key].clean(),this.gestureTimeoutStores[key].clean()}effect(){return this.config.shared.target&&this.bind(),()=>this._targetEventStore.clean()}bind(...args){const sharedConfig=this.config.shared,props={};let target;if(!sharedConfig.target||(target=sharedConfig.target(),target)){if(sharedConfig.enabled){for(const gestureKey of this.gestures){const gestureConfig=this.config[gestureKey],bindFunction=bindToProps(props,gestureConfig.eventOptions,!!target);if(gestureConfig.enabled){new(EngineMap.get(gestureKey))(this,args,gestureKey).bind(bindFunction)}}const nativeBindFunction=bindToProps(props,sharedConfig.eventOptions,!!target);for(const eventKey in this.nativeHandlers)nativeBindFunction(eventKey,"",(event=>this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({},this.state.shared),{},{event,args}))),void 0,!0)}for(const handlerProp in props)props[handlerProp]=chain(...props[handlerProp]);if(!target)return props;for(const handlerProp in props){const{device,capture,passive}=parseProp(handlerProp);this._targetEventStore.add(target,device,"",props[handlerProp],{capture,passive})}}}}function setupGesture(ctrl,gestureKey){ctrl.gestures.add(gestureKey),ctrl.gestureEventStores[gestureKey]=new EventStore(ctrl,gestureKey),ctrl.gestureTimeoutStores[gestureKey]=new TimeoutStore}const bindToProps=(props,eventOptions,withPassiveOption)=>(device,action,handler,options={},isNative=!1)=>{var _options$capture,_options$passive;const capture=null!==(_options$capture=options.capture)&&void 0!==_options$capture?_options$capture:eventOptions.capture,passive=null!==(_options$passive=options.passive)&&void 0!==_options$passive?_options$passive:eventOptions.passive;let handlerProp=isNative?device:toHandlerProp(device,action,capture);withPassiveOption&&passive&&(handlerProp+="Passive"),props[handlerProp]=props[handlerProp]||[],props[handlerProp].push(handler)},RE_NOT_NATIVE=/^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;function registerGesture(actions,handlers,handlerKey,key,internalHandlers,config){if(!actions.has(handlerKey))return;if(!EngineMap.has(key))return void 0;const startKey=handlerKey+"Start",endKey=handlerKey+"End";internalHandlers[key]=state=>{let memo;return state.first&&startKey in handlers&&handlers[startKey](state),handlerKey in handlers&&(memo=handlers[handlerKey](state)),state.last&&endKey in handlers&&handlers[endKey](state),memo},config[key]=config[key]||{}}function parseMergedHandlers(mergedHandlers,mergedConfig){const[handlers,nativeHandlers,actions]=function sortHandlers(_handlers){const native={},handlers={},actions=new Set;for(let key in _handlers)RE_NOT_NATIVE.test(key)?(actions.add(RegExp.lastMatch),handlers[key]=_handlers[key]):native[key]=_handlers[key];return[handlers,native,actions]}(mergedHandlers),internalHandlers={};return registerGesture(actions,handlers,"onDrag","drag",internalHandlers,mergedConfig),registerGesture(actions,handlers,"onWheel","wheel",internalHandlers,mergedConfig),registerGesture(actions,handlers,"onScroll","scroll",internalHandlers,mergedConfig),registerGesture(actions,handlers,"onPinch","pinch",internalHandlers,mergedConfig),registerGesture(actions,handlers,"onMove","move",internalHandlers,mergedConfig),registerGesture(actions,handlers,"onHover","hover",internalHandlers,mergedConfig),{handlers:internalHandlers,config:mergedConfig,nativeHandlers}}function useRecognizers(handlers,config={},gestureKey,nativeHandlers){const ctrl=react.useMemo((()=>new Controller(handlers)),[]);if(ctrl.applyHandlers(handlers,nativeHandlers),ctrl.applyConfig(config,gestureKey),react.useEffect(ctrl.effect.bind(ctrl)),react.useEffect((()=>ctrl.clean.bind(ctrl)),[]),void 0===config.target)return ctrl.bind.bind(ctrl)}function useWheel(handler,config){return actions_fe213e88_esm_registerAction(wheelAction),useRecognizers({wheel:handler},config||{},"wheel")}function useGesture(handlers,config){const hook=function createUseGesture(actions){return actions.forEach(actions_fe213e88_esm_registerAction),function useGesture(_handlers,_config){const{handlers,nativeHandlers,config}=parseMergedHandlers(_handlers,_config||{});return useRecognizers(handlers,config,void 0,nativeHandlers)}}([actions_fe213e88_esm_dragAction,actions_fe213e88_esm_pinchAction,actions_fe213e88_esm_scrollAction,wheelAction,actions_fe213e88_esm_moveAction,actions_fe213e88_esm_hoverAction]);return hook(handlers,config||{})}},"../../node_modules/@visx/event/esm/localPoint.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>localPoint});var _localPointGeneric__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/@visx/event/esm/localPointGeneric.js"),_typeGuards__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("../../node_modules/@visx/event/esm/typeGuards.js");function localPoint(nodeOrEvent,maybeEvent){if((0,_typeGuards__WEBPACK_IMPORTED_MODULE_1__.vq)(nodeOrEvent)&&maybeEvent)return(0,_localPointGeneric__WEBPACK_IMPORTED_MODULE_0__.A)(nodeOrEvent,maybeEvent);if((0,_typeGuards__WEBPACK_IMPORTED_MODULE_1__.xH)(nodeOrEvent)){var event=nodeOrEvent,node=event.target;if(node)return(0,_localPointGeneric__WEBPACK_IMPORTED_MODULE_0__.A)(node,event)}return null}},"../../node_modules/@visx/event/esm/localPointGeneric.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>localPoint});var Point=__webpack_require__("../../node_modules/@visx/point/esm/Point.js"),typeGuards=__webpack_require__("../../node_modules/@visx/event/esm/typeGuards.js");function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var DEFAULT_POINT={x:0,y:0};function localPoint(node,event){if(!node||!event)return null;var coords=function getXAndYFromEvent(event){if(!event)return _extends({},DEFAULT_POINT);if((0,typeGuards.kH)(event))return event.changedTouches.length>0?{x:event.changedTouches[0].clientX,y:event.changedTouches[0].clientY}:_extends({},DEFAULT_POINT);if((0,typeGuards.Er)(event))return{x:event.clientX,y:event.clientY};var target=null==event?void 0:event.target,boundingClientRect=target&&"getBoundingClientRect"in target?target.getBoundingClientRect():null;return boundingClientRect?{x:boundingClientRect.x+boundingClientRect.width/2,y:boundingClientRect.y+boundingClientRect.height/2}:_extends({},DEFAULT_POINT)}(event),svg=(0,typeGuards.xZ)(node)?node.ownerSVGElement:node,screenCTM=(0,typeGuards.GI)(svg)?svg.getScreenCTM():null;if((0,typeGuards.h1)(svg)&&screenCTM){var point=svg.createSVGPoint();return point.x=coords.x,point.y=coords.y,point=point.matrixTransform(screenCTM.inverse()),new Point.A({x:point.x,y:point.y})}var rect=node.getBoundingClientRect();return new Point.A({x:coords.x-rect.left-node.clientLeft,y:coords.y-rect.top-node.clientTop})}},"../../node_modules/@visx/event/esm/typeGuards.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function isElement(elem){return!!elem&&elem instanceof Element}function isSVGElement(elem){return!!elem&&(elem instanceof SVGElement||"ownerSVGElement"in elem)}function isSVGSVGElement(elem){return!!elem&&"createSVGPoint"in elem}function isSVGGraphicsElement(elem){return!!elem&&"getScreenCTM"in elem}function isTouchEvent(event){return!!event&&"changedTouches"in event}function isMouseEvent(event){return!!event&&"clientX"in event}function isEvent(event){return!!event&&(event instanceof Event||"nativeEvent"in event&&event.nativeEvent instanceof Event)}__webpack_require__.d(__webpack_exports__,{Er:()=>isMouseEvent,GI:()=>isSVGGraphicsElement,h1:()=>isSVGSVGElement,kH:()=>isTouchEvent,vq:()=>isElement,xH:()=>isEvent,xZ:()=>isSVGElement})},"../../node_modules/@visx/point/esm/Point.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>Point});var Point=function(){function Point(_ref){var _ref$x=_ref.x,x=void 0===_ref$x?0:_ref$x,_ref$y=_ref.y,y=void 0===_ref$y?0:_ref$y;this.x=0,this.y=0,this.x=x,this.y=y}var _proto=Point.prototype;return _proto.value=function value(){return{x:this.x,y:this.y}},_proto.toArray=function toArray(){return[this.x,this.y]},Point}()},"../../node_modules/@visx/zoom/esm/Zoom.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>esm_Zoom});var prop_types=__webpack_require__("../../node_modules/prop-types/index.js"),prop_types_default=__webpack_require__.n(prop_types),react=__webpack_require__("../../node_modules/react/index.js"),localPoint=__webpack_require__("../../node_modules/@visx/event/esm/localPoint.js"),use_gesture_react_esm=__webpack_require__("../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js");function createMatrix(_ref){var _ref$scaleX=_ref.scaleX,scaleX=void 0===_ref$scaleX?1:_ref$scaleX,_ref$scaleY=_ref.scaleY,scaleY=void 0===_ref$scaleY?1:_ref$scaleY,_ref$translateX=_ref.translateX,translateX=void 0===_ref$translateX?0:_ref$translateX,_ref$translateY=_ref.translateY,translateY=void 0===_ref$translateY?0:_ref$translateY,_ref$skewX=_ref.skewX,skewX=void 0===_ref$skewX?0:_ref$skewX,_ref$skewY=_ref.skewY;return{scaleX,scaleY,translateX,translateY,skewX,skewY:void 0===_ref$skewY?0:_ref$skewY}}function inverseMatrix(_ref2){var scaleX=_ref2.scaleX,scaleY=_ref2.scaleY,translateX=_ref2.translateX,translateY=_ref2.translateY,skewX=_ref2.skewX,skewY=_ref2.skewY,denominator=scaleX*scaleY-skewY*skewX;return{scaleX:scaleY/denominator,scaleY:scaleX/denominator,translateX:(scaleY*translateX-skewX*translateY)/-denominator,translateY:(skewY*translateX-scaleX*translateY)/denominator,skewX:skewX/-denominator,skewY:skewY/-denominator}}function applyMatrixToPoint(matrix,_ref3){var x=_ref3.x,y=_ref3.y;return{x:matrix.scaleX*x+matrix.skewX*y+matrix.translateX,y:matrix.skewY*x+matrix.scaleY*y+matrix.translateY}}function applyInverseMatrixToPoint(matrix,_ref4){var x=_ref4.x,y=_ref4.y;return applyMatrixToPoint(inverseMatrix(matrix),{x,y})}function translateMatrix(translateX,translateY){return createMatrix({translateX,translateY})}function multiplyMatrices(matrix1,matrix2){return{scaleX:matrix1.scaleX*matrix2.scaleX+matrix1.skewX*matrix2.skewY,scaleY:matrix1.skewY*matrix2.skewX+matrix1.scaleY*matrix2.scaleY,translateX:matrix1.scaleX*matrix2.translateX+matrix1.skewX*matrix2.translateY+matrix1.translateX,translateY:matrix1.skewY*matrix2.translateX+matrix1.scaleY*matrix2.translateY+matrix1.translateY,skewX:matrix1.scaleX*matrix2.skewX+matrix1.skewX*matrix2.scaleY,skewY:matrix1.skewY*matrix2.scaleX+matrix1.scaleY*matrix2.skewY}}function composeMatrices(){for(var _len=arguments.length,matrices=new Array(_len),_key=0;_key<_len;_key++)matrices[_key]=arguments[_key];switch(matrices.length){case 0:throw new Error("composeMatrices() requires arguments: was called with no args");case 1:return matrices[0];case 2:return multiplyMatrices(matrices[0],matrices[1]);default:var matrix1=matrices[0],matrix2=matrices[1],restMatrices=matrices.slice(2),matrix=multiplyMatrices(matrix1,matrix2);return composeMatrices.apply(void 0,[matrix].concat(restMatrices))}}function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}var defaultInitialTransformMatrix={scaleX:1,scaleY:1,translateX:0,translateY:0,skewX:0,skewY:0},defaultWheelDelta=function defaultWheelDelta(event){return-event.deltaY>0?{scaleX:1.1,scaleY:1.1}:{scaleX:.9,scaleY:.9}},defaultPinchDelta=function defaultPinchDelta(_ref){var s=_ref.offset[0],lastS=_ref.lastOffset[0];return{scaleX:s-lastS<0?.9:1.1,scaleY:s-lastS<0?.9:1.1}};function Zoom(_ref2){var _ref2$scaleXMin=_ref2.scaleXMin,scaleXMin=void 0===_ref2$scaleXMin?0:_ref2$scaleXMin,_ref2$scaleXMax=_ref2.scaleXMax,scaleXMax=void 0===_ref2$scaleXMax?1/0:_ref2$scaleXMax,_ref2$scaleYMin=_ref2.scaleYMin,scaleYMin=void 0===_ref2$scaleYMin?0:_ref2$scaleYMin,_ref2$scaleYMax=_ref2.scaleYMax,scaleYMax=void 0===_ref2$scaleYMax?1/0:_ref2$scaleYMax,_ref2$initialTransfor=_ref2.initialTransformMatrix,initialTransformMatrix=void 0===_ref2$initialTransfor?defaultInitialTransformMatrix:_ref2$initialTransfor,_ref2$wheelDelta=_ref2.wheelDelta,wheelDelta=void 0===_ref2$wheelDelta?defaultWheelDelta:_ref2$wheelDelta,_ref2$pinchDelta=_ref2.pinchDelta,pinchDelta=void 0===_ref2$pinchDelta?defaultPinchDelta:_ref2$pinchDelta,width=_ref2.width,height=_ref2.height,constrain=_ref2.constrain,children=_ref2.children,containerRef=(0,react.useRef)(null),matrixStateRef=(0,react.useRef)(initialTransformMatrix),_useState=(0,react.useState)(initialTransformMatrix),transformMatrix=_useState[0],setTransformMatrixState=_useState[1],_useState2=(0,react.useState)(!1),isDragging=_useState2[0],setIsDragging=_useState2[1],_useState3=(0,react.useState)(void 0),startTranslate=_useState3[0],setStartTranslate=_useState3[1],_useState4=(0,react.useState)(void 0),startPoint=_useState4[0],setStartPoint=_useState4[1],defaultConstrain=(0,react.useCallback)((function(newTransformMatrix,prevTransformMatrix){if(constrain)return constrain(newTransformMatrix,prevTransformMatrix);var scaleX=newTransformMatrix.scaleX,scaleY=newTransformMatrix.scaleY;return scaleX>scaleXMax||scaleX<scaleXMin||(scaleY>scaleYMax||scaleY<scaleYMin)?prevTransformMatrix:newTransformMatrix}),[constrain,scaleXMin,scaleXMax,scaleYMin,scaleYMax]),setTransformMatrix=(0,react.useCallback)((function(newTransformMatrix){setTransformMatrixState((function(prevTransformMatrix){var updatedTransformMatrix=defaultConstrain(newTransformMatrix,prevTransformMatrix);return matrixStateRef.current=updatedTransformMatrix,updatedTransformMatrix}))}),[defaultConstrain]),applyToPoint=(0,react.useCallback)((function(_ref3){var x=_ref3.x,y=_ref3.y;return applyMatrixToPoint(transformMatrix,{x,y})}),[transformMatrix]),applyInverseToPoint=(0,react.useCallback)((function(_ref4){var x=_ref4.x,y=_ref4.y;return applyInverseMatrixToPoint(transformMatrix,{x,y})}),[transformMatrix]),reset=(0,react.useCallback)((function(){setTransformMatrix(initialTransformMatrix)}),[initialTransformMatrix,setTransformMatrix]),scale=(0,react.useCallback)((function(_ref5){var scaleX=_ref5.scaleX,maybeScaleY=_ref5.scaleY,point=_ref5.point,scaleY=maybeScaleY||scaleX,cleanPoint=point||{x:width/2,y:height/2},translate=applyInverseMatrixToPoint(matrixStateRef.current,cleanPoint),nextMatrix=composeMatrices(matrixStateRef.current,translateMatrix(translate.x,translate.y),function scaleMatrix(scaleX,maybeScaleY){return void 0===maybeScaleY&&(maybeScaleY=void 0),createMatrix({scaleX,scaleY:maybeScaleY||scaleX})}(scaleX,scaleY),translateMatrix(-translate.x,-translate.y));if(setTransformMatrix(nextMatrix),isDragging){var _matrixStateRef$curre=matrixStateRef.current,translateX=_matrixStateRef$curre.translateX,translateY=_matrixStateRef$curre.translateY;setStartPoint(point),setStartTranslate({translateX,translateY})}}),[height,width,isDragging,setTransformMatrix]),translate=(0,react.useCallback)((function(_ref6){var translateX=_ref6.translateX,translateY=_ref6.translateY,nextMatrix=composeMatrices(transformMatrix,translateMatrix(translateX,translateY));setTransformMatrix(nextMatrix)}),[setTransformMatrix,transformMatrix]),setTranslate=(0,react.useCallback)((function(_ref7){var translateX=_ref7.translateX,translateY=_ref7.translateY,nextMatrix=_extends({},transformMatrix,{translateX,translateY});setTransformMatrix(nextMatrix)}),[setTransformMatrix,transformMatrix]),translateTo=(0,react.useCallback)((function(_ref8){var x=_ref8.x,y=_ref8.y,point=applyInverseMatrixToPoint(transformMatrix,{x,y});setTranslate({translateX:point.x,translateY:point.y})}),[setTranslate,transformMatrix]),invert=(0,react.useCallback)((function(){return inverseMatrix(transformMatrix)}),[transformMatrix]),toStringInvert=(0,react.useCallback)((function(){var _invert=invert(),translateX=_invert.translateX,translateY=_invert.translateY,scaleX=_invert.scaleX,scaleY=_invert.scaleY,skewX=_invert.skewX;return"matrix("+scaleX+", "+_invert.skewY+", "+skewX+", "+scaleY+", "+translateX+", "+translateY+")"}),[invert]),dragStart=(0,react.useCallback)((function(event){var translateX=transformMatrix.translateX,translateY=transformMatrix.translateY;setStartPoint((0,localPoint.A)(event)||void 0),setStartTranslate({translateX,translateY}),setIsDragging(!0)}),[transformMatrix]),dragMove=(0,react.useCallback)((function(event,options){var _options$offsetX,_options$offsetY;if(isDragging&&startPoint&&startTranslate){var currentPoint=(0,localPoint.A)(event),dx=currentPoint?-(startPoint.x-currentPoint.x):-startPoint.x,dy=currentPoint?-(startPoint.y-currentPoint.y):-startPoint.y,translateX=startTranslate.translateX+dx;null!=options&&options.offsetX&&(translateX+=null!=(_options$offsetX=null==options?void 0:options.offsetX)?_options$offsetX:0);var translateY=startTranslate.translateY+dy;null!=options&&options.offsetY&&(translateY+=null!=(_options$offsetY=null==options?void 0:options.offsetY)?_options$offsetY:0),setTranslate({translateX,translateY})}}),[isDragging,setTranslate,startPoint,startTranslate]),dragEnd=(0,react.useCallback)((function(){setStartPoint(void 0),setStartTranslate(void 0),setIsDragging(!1)}),[]),handleWheel=(0,react.useCallback)((function(event){event.preventDefault();var point=(0,localPoint.A)(event)||void 0,_ref9=wheelDelta(event),scaleX=_ref9.scaleX,scaleY=_ref9.scaleY;scale({scaleX,scaleY,point})}),[scale,wheelDelta]),handlePinch=(0,react.useCallback)((function(state){var _state$origin=state.origin,ox=_state$origin[0],oy=_state$origin[1],currentMemo=state.memo;if(containerRef.current){var _currentMemo,_ref10=null!=(_currentMemo=currentMemo)?_currentMemo:containerRef.current.getBoundingClientRect(),top=_ref10.top,left=_ref10.left;currentMemo||(currentMemo={top,left});var _pinchDelta=pinchDelta(state),scaleX=_pinchDelta.scaleX,scaleY=_pinchDelta.scaleY;scale({scaleX,scaleY,point:{x:ox-left,y:oy-top}})}return currentMemo}),[scale,pinchDelta]),toString=(0,react.useCallback)((function(){var translateX=transformMatrix.translateX,translateY=transformMatrix.translateY,scaleX=transformMatrix.scaleX,scaleY=transformMatrix.scaleY,skewX=transformMatrix.skewX;return"matrix("+scaleX+", "+transformMatrix.skewY+", "+skewX+", "+scaleY+", "+translateX+", "+translateY+")"}),[transformMatrix]),center=(0,react.useCallback)((function(){var centerPoint={x:width/2,y:height/2},inverseCentroid=applyInverseToPoint(centerPoint);translate({translateX:inverseCentroid.x-centerPoint.x,translateY:inverseCentroid.y-centerPoint.y})}),[height,width,applyInverseToPoint,translate]),clear=(0,react.useCallback)((function(){setTransformMatrix({scaleX:1,scaleY:1,translateX:0,translateY:0,skewX:0,skewY:0})}),[setTransformMatrix]);(0,use_gesture_react_esm.useGesture)({onDragStart:function onDragStart(_ref11){var event=_ref11.event;event instanceof KeyboardEvent||dragStart(event)},onDrag:function onDrag(_ref12){var event=_ref12.event,pinching=_ref12.pinching,cancel=_ref12.cancel;pinching?(cancel(),dragEnd()):event instanceof KeyboardEvent||dragMove(event)},onDragEnd:dragEnd,onPinch:handlePinch,onWheel:function onWheel(_ref13){var event=_ref13.event,active=_ref13.active;!_ref13.pinching&&active&&handleWheel(event)}},{target:containerRef,eventOptions:{passive:!1},drag:{filterTaps:!0}});var zoom={initialTransformMatrix,transformMatrix,isDragging,center,clear,scale,translate,translateTo,setTranslate,setTransformMatrix,reset,handleWheel,handlePinch,dragEnd,dragMove,dragStart,toString,invert,toStringInvert,applyToPoint,applyInverseToPoint,containerRef};return react.createElement(react.Fragment,null,children(zoom))}Zoom.propTypes={width:prop_types_default().number.isRequired,height:prop_types_default().number.isRequired,wheelDelta:prop_types_default().func,scaleXMin:prop_types_default().number,scaleXMax:prop_types_default().number,scaleYMin:prop_types_default().number,scaleYMax:prop_types_default().number,constrain:prop_types_default().func,children:prop_types_default().func.isRequired};const esm_Zoom=Zoom},"../../node_modules/lodash/throttle.js":(module,__unused_webpack_exports,__webpack_require__)=>{var debounce=__webpack_require__("../../node_modules/lodash/debounce.js"),isObject=__webpack_require__("../../node_modules/lodash/isObject.js");module.exports=function throttle(func,wait,options){var leading=!0,trailing=!0;if("function"!=typeof func)throw new TypeError("Expected a function");return isObject(options)&&(leading="leading"in options?!!options.leading:leading,trailing="trailing"in options?!!options.trailing:trailing),debounce(func,wait,{leading,maxWait:wait,trailing})}}}]);