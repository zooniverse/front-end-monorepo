{"version":3,"file":"components-shared-BarChart-BarChart-stories.5dc9ba6c.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AA0CA","sources":["webpack://@zooniverse/user/./src/components/shared/BarChart/BarChart.jsx"],"sourcesContent":["import { DataChart, ResponsiveContext, Text } from 'grommet'\nimport { arrayOf, func, number, shape, string } from 'prop-types'\nimport { useContext } from 'react'\nimport styled from 'styled-components'\nimport { useTranslation } from '@translations/i18n'\n\nimport {\n  getDateInterval as defaultGetDateInterval\n} from '@utils'\n\nimport { getCompleteData as defaultGetCompleteData } from './helpers/getCompleteData.js'\nimport getDateRangeLabel from './helpers/getDateRangeLabel.js'\n\nconst X_AXIS_FREQUENCY = {\n  everyOther: 'everyOther',\n  everyFourth: 'everyFourth'\n}\n\nconst StyledDataChart = styled(DataChart)`\n  .hidden-period-label {\n    display: none;\n  }\n\n  // The only way to get to the x-axis bounding div\n  &.styled-grommet-barchart > :first-child {\n\n    // Align the x-axis visual label to the first date label\n    div:first-of-type > span {\n      position: relative;\n\n      &::after {\n        content: 'Date range (UTC)';\n        position: absolute;\n        top: calc(100% + 5px);\n        left: 0;\n        font-size: 0.75rem;\n        width: max-content;\n      }\n    }\n  }\n`\n\nfunction BarChart({\n  data = [],\n  dateRange,\n  getCompleteData = defaultGetCompleteData,\n  getDateInterval = defaultGetDateInterval,\n  type = 'count'\n}) {\n  const { t } = useTranslation()\n  const size = useContext(ResponsiveContext)\n\n  const TYPE_LABEL = {\n    count: t('common.classifications'),\n    session_time: t('BarChart.time')\n  }\n\n  // getDateInterval returns an object with a period property based on the date range, start_date, and end_date\n  const dateInterval = getDateInterval(dateRange)\n\n  // getCompleteData returns an array of objects with a period, count, and session_time property,\n  // including any periods without stats with a count and session_time of 0\n  const completeData = getCompleteData({ data, dateInterval })\n\n  const dateRangeLabel = getDateRangeLabel(dateInterval, t)\n  const typeLabel = TYPE_LABEL[type]\n\n  // with no data set gradient as 'brand'\n  let gradient = 'brand'\n  // with data set gradient range based on data type (count or session_time) and max value of data type\n  if (data.length > 0) {\n    const types = data.map((d) => d[type])\n    const max = Math.max(...types)\n    gradient = [\n      { value: 0, color: 'neutral-1' },\n      { value: max, color: 'brand' }\n    ]\n  }\n\n  // set chart options based on screen size and data length\n  const chartOptions = {\n    color: gradient,\n    property: type,\n    type: 'bar'\n  }\n\n  let xAxisFrequency\n  if (completeData.length > 12 && completeData.length < 25) {\n    xAxisFrequency = X_AXIS_FREQUENCY.everyOther\n  } else if (completeData.length > 24) {\n    xAxisFrequency = X_AXIS_FREQUENCY.everyFourth\n  }\n\n  if (size !== 'small' && completeData.length < 9) {\n    chartOptions.thickness = 'xlarge'\n  }\n  if (size === 'small') {\n    xAxisFrequency = xAxisFrequency || X_AXIS_FREQUENCY.everyOther\n\n    if (completeData.length < 12) {\n      chartOptions.thickness = 'small'\n    } else if (completeData.length > 11 && completeData.length < 19) {\n      chartOptions.thickness = 'xsmall'\n    } else {\n      chartOptions.thickness = 'hair'\n    }\n  }\n\n  return (\n    <StyledDataChart\n      a11yTitle={t('BarChart.a11y', { typeLabel, countLabel: dateRangeLabel.countLabel, startDate: dateRange.startDate, endDate: dateRange.endDate })}\n      className='styled-grommet-barchart'\n      axis={{\n        x: { granularity: 'fine', property: 'period' },\n        y: { granularity: 'fine', property: type },\n      }}\n      chart={chartOptions}\n      data={completeData}\n      detail={!!completeData?.length}\n      guide={{\n        y: {\n          granularity: 'fine'\n        }\n      }}\n      series={[\n        {\n          property: 'period',\n          label: dateRangeLabel.countLabel,\n          render: ((period, datum, datumIndex) => {\n            const date = new Date(period)\n\n            if (xAxisFrequency === X_AXIS_FREQUENCY.everyOther && datum?.index % 2 !== 0) {\n              return (\n                <Text\n                  className='hidden-period-label'\n                  data-testid='periodLabel'\n                  textAlign='center'\n                >\n                  {date.toLocaleDateString('en-US', dateRangeLabel.tLDS)}\n                </Text>\n              )\n            } else if (xAxisFrequency === X_AXIS_FREQUENCY.everyFourth && datum?.index % 4 !== 0) {\n              return (\n                <Text\n                  className='hidden-period-label'\n                  data-testid='periodLabel'\n                  textAlign='center'\n                >\n                  {date.toLocaleDateString('en-US', dateRangeLabel.tLDS)}\n                </Text>\n              )\n            } else {\n              return (\n                <Text\n                  data-testid='periodLabel'\n                  textAlign='center'\n                >\n                  {date.toLocaleDateString('en-US', dateRangeLabel.tLDS)}\n                </Text>\n              )\n            }\n          }),\n        },\n        {\n          property: type,\n          label: typeLabel,\n          render: ((number) => {\n            if (type === 'session_time') {\n              const time = number / dateRangeLabel.time\n              const timeLabelText = dateRangeLabel.timeLabel === 'hrs' ? `${time.toFixed(1).toLocaleString()} ${dateRangeLabel.timeLabel}` : `${time.toFixed(0).toLocaleString()} ${dateRangeLabel.timeLabel}`\n              return (\n                <Text data-testid='timeLabel'>\n                  {timeLabelText}\n                </Text>\n              )\n            } else {\n              return (\n                <Text data-testid='countLabel'>\n                  {number.toLocaleString()}\n                </Text>\n              )\n            }\n          }),\n        },\n      ]}\n      size='fill'\n    />\n  )\n}\n\nBarChart.propTypes = {\n  data: arrayOf(shape({\n    period: string,\n    count: number,\n    session_time: number\n  })),\n  dateRange: shape({\n    endDate: string,\n    startDate: string\n  }),\n  getCompleteData: func,\n  getDateInterval: func,\n  type: string\n}\n\nexport default BarChart\n"],"names":[],"ignoreList":[],"sourceRoot":""}